<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¯­éŸ³å·¥ä½œå®¤ Pro (ä¸€ä½“åŒ–å·¥ä½œå°)</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        .main-container.spa-layout { grid-template-columns: 0.8fr 0.8fr 0.8fr 1.8fr; }
        .readonly-timbre { padding: 0.5rem; background-color: #f8f9fa; border: 1px solid transparent; border-radius: 4px; font-size: 0.9rem; color: var(--text-color-secondary); }
        .actions-cell, .character-actions, .timbre-actions { display: flex; align-items: center; gap: 0.5rem; }
        
		.actions-cell {
			display: flex; /* ç¡®ä¿å®ƒæ˜¯ä¸€ä¸ªflexå®¹å™¨ */
			flex-direction: column;
			gap: 0.5rem; /* ä¸ºä¸¤è¡Œä¹‹é—´è®¾ç½®ä¸€ä¸ªæ ‡å‡†çš„å‚ç›´é—´è· */
		}
        .action-row { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; justify-content: flex-start;}
        .audio-player-btn, .btn-show-roles, .btn-settings {
            width: 24px; height: 24px; cursor: pointer; border-radius: 50%;
            background-color: transparent; color: var(--text-color-secondary); border: 1px solid transparent;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; padding: 0; flex-shrink: 0; transition: background-color 0.2s, color 0.2s;
        }
        .btn-show-roles { font-size: 12px; }
        .audio-player-btn:hover:not(:disabled), .btn-show-roles:hover, .btn-settings:hover { background-color: #e8f0fe; color: var(--primary-color); }
        .btn-assign { padding: 0.2rem 0.6rem; font-size: 0.75rem; }
        .popover-container { position: relative; }
        .popover-content {
            display: none; position: absolute; right: 105%; top: 50%; transform: translateY(-50%); width: max-content;
            background-color: #333; color: white; padding: 0.5rem; border-radius: var(--border-radius); z-index: 10;
            font-size: 0.85rem; line-height: 1.4; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .popover-content ul { list-style: none; padding: 0; margin: 0; }
        .popover-content li { padding: 0.2rem 0; }
        .btn-show-roles:focus + .popover-content, .popover-container:focus-within .popover-content { display: block; }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); display: none;
            align-items: center; justify-content: center; z-index: 1000;
        }
        .modal-content { background-color: var(--surface-color); padding: 2rem; border-radius: var(--border-radius); width: 90%; max-width: 500px; }
        .modal-header { font-size: 1.2rem; margin-bottom: 1.5rem; }
        .modal-actions { margin-top: 1.5rem; display: flex; justify-content: flex-end; gap: 0.75rem; }
        .mode-select { max-width: 80px; }
        .instruct-input { margin-top: 0.5rem; font-size: 0.85rem; padding: 0.4rem; display: none; }
        .character-actions .value { text-align: right; }
        #profileModalBody dl { margin: 0; }
        #profileModalBody dt { font-weight: bold; color: var(--text-color-secondary); margin-top: 0.75rem; }
        #profileModalBody dd { margin-left: 0; margin-bottom: 0.75rem; }
		#dialogueModalBody ul {
			list-style: none;
			padding: 0;
			margin: 0;
		}
		#dialogueModalBody li {
			padding: 0.75rem;
			border-bottom: 1px solid var(--border-color);
			line-height: 1.6;
		}
		#dialogueModalBody li:last-child {
			border-bottom: none;
		}
		#dialogueModalBody .dialogue-source {
			display: block;
			font-size: 0.8rem;
			color: var(--text-color-secondary);
			font-style: italic;
			margin-bottom: 0.25rem;
		}
        /* *** æ ¸å¿ƒä¿®æ”¹ï¼šæ·»åŠ ä»¥ä¸‹æ–°è§„åˆ™ *** */
        .content-table .actions-cell .btn {
            padding: 0.2rem 0.6rem; /* å‡å°å†…è¾¹è· (ä¸Šä¸‹ 0.2rem, å·¦å³ 0.6rem) */
            font-size: 0.8rem;      /* å‡å°å­—ä½“å¤§å° */
            height: 26px;           /* å›ºå®šä¸€ä¸ªè¾ƒå°çš„é«˜åº¦ */
        }

        .content-table .actions-cell .mode-select {
            padding: 0.2rem;        /* å‡å°ä¸‹æ‹‰æ¡†çš„å†…è¾¹è· */
            font-size: 0.8rem;      /* å‡å°å­—ä½“å¤§å° */
            height: 26px;           /* ä¸æŒ‰é’®é«˜åº¦ä¿æŒä¸€è‡´ */
            max-width: 70px;        /* å¯ä»¥é€‚å½“å‡å°æœ€å¤§å®½åº¦ */
        }

		/* 1. Popover çš„å¤–å±‚å®¹å™¨ */
		.popover-container {
			position: relative; /* å¿…é¡»ï¼Œä¸ºå†…éƒ¨ç»å¯¹å®šä½çš„ popover-content æä¾›åŸºå‡† */
		}

		/* 2. Popover çš„å†…å®¹åŒºåŸŸï¼ˆé€šç”¨æ ·å¼ï¼‰ */
		.popover-content {
			display: none; /* é»˜è®¤éšè— */
			position: absolute;
			z-index: 10;
			
			/* ç»Ÿä¸€æ ·å¼ï¼šç™½è‰²èƒŒæ™¯ã€è¾¹æ¡†ã€åœ†è§’ã€é˜´å½± */
			background-color: var(--surface-color);
			border: 1px solid var(--border-color);
			border-radius: var(--border-radius);
			box-shadow: 0 4px 12px rgba(0,0,0,0.1);
			
			/* ç»Ÿä¸€æ ·å¼ï¼šå†…è¾¹è·å’Œæœ€å°å®½åº¦ */
			padding: 0.5rem;
			min-width: 180px; /* è®¾ç½®ä¸€ä¸ªåˆé€‚çš„æœ€å°å®½åº¦ */

			/* æ–‡å­—æ ·å¼ */
			font-size: 0.875rem;
			color: var(--text-color-primary);
			text-align: left;
			
			/* åŠ¨ç”»æ•ˆæœ */
			opacity: 0;
			transform: translateY(5px);
			transition: opacity 0.2s ease, transform 0.2s ease;
			pointer-events: none;
		}

		/* 3. è§¦å‘ Popover æ˜¾ç¤ºçš„é€»è¾‘ */
		.popover-container:focus-within .popover-content {
			display: block;
			opacity: 1;
			transform: translateY(0);
			pointer-events: auto;
		}

		/* 4. Popover å†…éƒ¨çš„åˆ—è¡¨æ ·å¼ */
		.popover-content ul {
			list-style: none;
			padding: 0;
			margin: 0;
			color: var(--text-color-primary);
		}
		.popover-content li {
			padding: 0.25rem 0.5rem; /* è°ƒæ•´åˆ—è¡¨é¡¹çš„é—´è· */
		}

		/* 5. ç‰¹åˆ«ä¸ºâ€œå·²åˆ†é…è§’è‰²â€çš„ popover å¢åŠ ä¸€ç‚¹æ ‡é¢˜æ ·å¼ */
		.popover-content strong {
			display: block;
			margin-bottom: 0.5rem;
			padding-bottom: 0.5rem;
			border-bottom: 1px solid var(--border-color);
			font-weight: 500;
		}

		/* 6. (ä¿ç•™) Popover å†…éƒ¨çš„èœå•æŒ‰é’®æ ·å¼ (ç”¨äºç‰¹æ•ˆèœå•å’Œåˆ†ç±»ç§»åŠ¨èœå•) */
		.popover-content li button {
			display: block;
			width: 100%;
			padding: 0.5rem 0.75rem;
			border: none;
			background: none;
			cursor: pointer;
			text-align: left;
			color: var(--text-color-primary);
			transition: background-color 0.2s;
			border-radius: 4px;
		}
		.popover-content li button:hover {
			background-color: var(--selection-color);
		}
				
		/* 3. (å¯é€‰ä½†æ¨è) ç»Ÿä¸€ä¸¤ç§ä¸åŒpopoverçš„æ ·å¼ï¼Œè®©â€œæŸ¥çœ‹å…³è”è§’è‰²â€ä¹Ÿå˜å¥½çœ‹ */
		#timbre-list .popover-content {
			background-color: var(--surface-color);
			border: 1px solid var(--border-color);
			border-radius: var(--border-radius);
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			padding: 0.5rem;
			min-width: 150px;
			text-align: left; /* ç¡®ä¿æ–‡å­—å·¦å¯¹é½ */
		}
		#timbre-list .popover-content ul {
			padding-left: 0;
		}
		
		/* *** æ ¸å¿ƒä¿®æ”¹ 1: æ·»åŠ é«˜äº®æ ·å¼ *** */
        /* é’ˆå¯¹è¡Œé¦–çš„æ“ä½œæŒ‰é’® (X å’Œ +) */
        .content-table .row-actions .btn {
            width: 24px;         /* è®¾ç½®ä¸€ä¸ªå›ºå®šçš„å®½åº¦ */
            height: 24px;        /* è®¾ç½®ä¸€ä¸ªå›ºå®šçš„é«˜åº¦ï¼Œä½¿å…¶å˜ä¸ºæ–¹å½¢ */
            padding: 0;          /* ç§»é™¤æ‰€æœ‰å†…è¾¹è· */
            font-size: 1rem;     /* å¯ä»¥é€‚å½“è°ƒæ•´å­—ä½“å¤§å°æ¥æ§åˆ¶ç¬¦å·å¤§å° */
            line-height: 22px;   /* å°è¯•è®©ç¬¦å·å‚ç›´å±…ä¸­ */
            text-align: center;
        }
		.content-table tbody tr.highlighted-row {
			background-color: var(--highlight-color); /* ä½¿ç”¨æˆ‘ä»¬åœ¨:rootä¸­å®šä¹‰çš„å…¨å±€é«˜äº®è‰² */
			transition: background-color 0.3s ease;
		}
		/* å¯é€‰ï¼šä¸ºé«˜äº®è¡Œçš„å•å…ƒæ ¼æ·»åŠ ä¸€ä¸ªå·¦è¾¹æ¡†ï¼Œä½¿å…¶æ›´é†’ç›® */
		.content-table tbody tr.highlighted-row td:first-child {
			border-left: 3px solid var(--primary-color);
		}
		.settings-container {
			display: flex;
			padding: 1.5rem 2rem;
		}
		.settings-tabs {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
			border-right: 1px solid var(--border-color);
			padding-right: 1.5rem;
			flex-shrink: 0;
		}
		.settings-tabs .tab-link {
			border: none;
			background: none;
			padding: 0.5rem 1rem;
			cursor: pointer;
			text-align: left;
			border-radius: 4px;
			font-size: 0.9rem;
			color: var(--text-color-secondary);
			transition: background-color 0.2s, color 0.2s;
			min-width: 120px;
		}
		.settings-tabs .tab-link:hover {
			background-color: #f1f3f4;
		}
		.settings-tabs .tab-link.active {
			background-color: var(--selection-color);
			color: var(--primary-color);
			font-weight: 500;
		}
		.settings-content {
			padding-left: 1.5rem;
			flex-grow: 1;
		}
		.tab-content {
			display: none;
		}
		.tab-content.active {
			display: block;
		}
		.config-group.inline-group {
			display: flex;
			align-items: center; /* å‚ç›´å±…ä¸­å¯¹é½ */
			gap: 0.75rem;      /* æ ‡ç­¾å’Œè¾“å…¥æ¡†ä¹‹é—´çš„é—´è· */
		}

		.config-group.inline-group label {
			margin-bottom: 0; /* ç§»é™¤ label é»˜è®¤çš„ä¸‹è¾¹è· */
			flex-shrink: 0;   /* é˜²æ­¢æ ‡ç­¾æ–‡å­—åœ¨ç©ºé—´ä¸è¶³æ—¶è¢«å‹ç¼©æ¢è¡Œ */
		}

		.config-group.inline-group select,
		.config-group.inline-group input,
		.config-group.inline-group .btn-group { /* å¢åŠ å¯¹æŒ‰é’®ç»„çš„æ”¯æŒ */
			flex-grow: 1; /* è®©è¾“å…¥æ¡†æˆ–ä¸‹æ‹‰æ¡†å æ®æ‰€æœ‰å‰©ä½™ç©ºé—´ */
		}
				
		.timbre-override-select .placeholder-option {
			color: #80868b; /* ä¸€ç§æŸ”å’Œçš„ç°è‰² */
			font-style: italic; /* æ–œä½“ */
		}
			
		.player-modal-body {
			display: flex;
			flex-direction: column;
			gap: 1.5rem; /* æ§ä»¶å’Œæ—¶é—´çº¿ä¹‹é—´çš„é—´è· */
			padding: 1rem 0;
		}

		.player-controls {
			display: flex;
			justify-content: center;
		}

		#playerPlayPauseBtn {
			width: 50px;
			height: 50px;
			border-radius: 50%;
			font-size: 24px;
			padding: 0;
			line-height: 50px; /* ç¡®ä¿å›¾æ ‡å‚ç›´å±…ä¸­ */
		}

		.player-timeline {
			display: flex;
			align-items: center;
			gap: 1rem; /* æ—¶é—´å’Œè¿›åº¦æ¡ä¹‹é—´çš„é—´è· */
		}

		.time-display {
			font-size: 0.9rem;
			color: var(--text-color-secondary);
			font-variant-numeric: tabular-nums;
		}

		.progress-bar-slider {
			flex-grow: 1;
			-webkit-appearance: none;
			appearance: none;
			width: 100%;
			height: 5px;
			background: #ddd;
			outline: none;
			border-radius: 2.5px;
			cursor: pointer;
		}

		.progress-bar-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 16px;
			height: 16px;
			background: var(--primary-color);
			border-radius: 50%;
			margin-top: -5.5px;
		}

		.progress-bar-slider::-moz-range-thumb {
			width: 16px;
			height: 16px;
			background: var(--primary-color);
			border-radius: 50%;
			border: none;
		}
		.audio-player-btn.playable {
			color: var(--primary-color); /* å°†å›¾æ ‡é¢œè‰²è®¾ä¸ºä¸»é¢˜è“è‰² */
			cursor: pointer;
		}

		.audio-player-btn.playable:hover {
			background-color: #e8f0fe; /* é¼ æ ‡æ‚¬åœæ—¶ï¼Œä½¿ç”¨æ·¡è“è‰²èƒŒæ™¯ï¼ˆä¸éŸ³è‰²åº“æŒ‰é’®æ‚¬åœæ•ˆæœä¸€è‡´ï¼‰ */
			transform: scale(1.1); /* ï¼ˆå¯é€‰ï¼‰è½»å¾®æ”¾å¤§æ•ˆæœï¼Œå¢å¼ºäº¤äº’æ„Ÿ */
		}
		
		/* ---ä¸ºå†…å®¹ç¼–è¾‘å™¨è¡¨æ ¼è¡Œæ·»åŠ è¾¹æ¡†å’Œå†…è¾¹è· --- */
		.content-table tbody td {
			padding-top: 0.75rem;     /* å¢åŠ é¡¶éƒ¨å†…è¾¹è· */
			padding-bottom: 0.75rem;  /* å¢åŠ åº•éƒ¨å†…è¾¹è·ï¼Œæ‹‰å¼€è¡Œé—´è· */
			border-bottom: 1px solid var(--border-color); /* åœ¨æ¯è¡Œä¸‹æ–¹æ·»åŠ ä¸€æ¡åˆ†å‰²çº¿ */
			vertical-align: middle; /* ç¡®ä¿å•å…ƒæ ¼å†…å®¹å‚ç›´å±…ä¸­ï¼Œä½¿æŒ‰é’®å’Œæ–‡æœ¬å¯¹é½æ›´å¥½çœ‹ */
		}

		/* ç§»é™¤æœ€åä¸€è¡Œå¤šä½™çš„è¾¹æ¡†ï¼Œä½¿è¡¨æ ¼åº•éƒ¨æ›´æ•´æ´ */
		.content-table tbody tr:last-child td {
			border-bottom: none;
		}
		
		/* 1. Popoverèœå•çš„é€šç”¨æ ·å¼å¢å¼º */
		.popover-content ul {
			list-style: none;
			padding: 0;
			margin: 0;
		}
		.popover-content li button {
			display: block;
			width: 100%;
			padding: 0.5rem 1rem;
			border: none;
			background: none;
			cursor: pointer;
			text-align: left;
			color: var(--text-color-primary);
			transition: background-color 0.2s;
		}
		.popover-content li button:hover {
			background-color: var(--selection-color);
		}

		/* 2. ä¸ºæ–°çš„åˆ†ç±»ç§»åŠ¨èœå•è®¾ç½®æœ€å°å®½åº¦ */
		.category-menu {
			min-width: 150px;
			max-height: 900px;
			overflow-y: auto;
		}

		/* 3. ä¸ºæ—§çš„â€œåˆ†é…â€æŒ‰é’®é‡å‘½åclassï¼Œé¿å…å†²çª */
		/*    è¿™ä¸ªæŒ‰é’®åœ¨è§’è‰²åˆ—è¡¨ï¼ˆç¬¬äºŒåˆ—ï¼‰ä¸­ä½¿ç”¨ */
		.btn-assign-char {
			padding: 0.2rem 0.6rem;
			font-size: 0.75rem;
		}
			
    </style>
</head>
<body>
<div class="main-layout">
    <!-- Global Header -->
    <header class="global-header">
        <h1 class="app-title">AI è¯­éŸ³å·¥ä½œå®¤ Pro</h1>
        <div class="status-group">
            <p id="global-status">æ¬¢è¿ä½¿ç”¨ï¼è¯·åœ¨å·¦ä¾§é€‰æ‹©æˆ–ä¸Šä¼ å°è¯´ä»¥å¼€å§‹ã€‚</p>
            <div id="global-progress" class="progress-bar"><div class="progress-bar-inner"></div></div>
        </div>
        <div class="actions-group">
			<button id="processTxtBtn" class="btn" disabled>å¤„ç†æ–‡æœ¬</button>
            <button id="processAllBtn" class="btn btn-primary" disabled>ç”Ÿæˆå£°éŸ³</button>
            <button id="downloadSpliceBtn" class="btn" disabled>ä¸‹è½½å£°éŸ³</button>
            <button id="settingsBtn" class="btn-settings" title="å…¨å±€è®¾ç½®">âš™ï¸</button>
        </div>
    </header>

    <!-- 4-Column Workspace -->
    <main class="main-container spa-layout">
        <!-- Column 1: Novel Management & Processing -->
		<div class="content-column">
			<h2 class="column-header">å°è¯´ç®¡ç†ä¸å¤„ç†</h2>
			
            <div style="display: flex; gap: 1rem; margin-bottom: 1rem; align-items: flex-end;">
                <!-- å·¦ä¾§ï¼šæ¨¡å‹é€‰æ‹© (å·²ä¿®æ”¹ä¸ºè¡Œå†…å¸ƒå±€) -->
                <div class="config-group inline-group" style="flex: 1;">
                    <label for="llmModelSelector">é€‰æ‹©å¤„ç†æ¨¡å‹</label>
                    <select id="llmModelSelector">
                        <option value="gemini-1.5-flash">Gemini Flash</option>
                        <option value="qwen-plus">é€šä¹‰åƒé—® Plus</option>
                    </select>
                </div>
                <!-- å³ä¾§ï¼šä¸Šä¼ æŒ‰é’® -->
				<div class="config-group" style="flex: 0.6;">
					<button id="uploadTxtLabelBtn" class="btn" style="width: 100%; justify-content: center;">ä¸Šä¼ æ–°å°è¯´</button>
					<input type="file" id="novelTxtFile" accept=".txt" style="display: none;">
				</div>
            </div>
			<div class="config-group inline-group">
				<label for="novelSelector">é€‰æ‹©å°è¯´é¡¹ç›®</label>
                <div class="btn-group" style="display: flex; gap: 0.5rem; width: 100%;">
				    <select id="novelSelector" style="flex-grow: 1;"><option>æ­£åœ¨åŠ è½½...</option></select>
                    <button id="deleteNovelBtn" class="btn btn-danger" title="åˆ é™¤å½“å‰é€‰ä¸­çš„å°è¯´é¡¹ç›®" disabled style="padding: 0.5rem; flex-shrink: 0;">ğŸ—‘ï¸</button>
                </div>
			</div>
			<hr style="border: none; border-top: 1px solid var(--border-color); margin: 1rem 0;">
			
			<!-- NEW: This wrapper will contain everything that scrolls -->
			<div id="col1-content-wrapper" class="scrollable-content">
				<!-- This is now the fixed controls container -->
				<div class="chapter-controls">
					<div class="config-group">
						<label>ç« èŠ‚åˆ—è¡¨ (å¯å¤šé€‰)</label>
						<div class="controls" style="display: flex; gap: 0.5rem;">
							<button id="selectAllChaptersBtn" class="btn">å…¨é€‰</button>
							<button id="selectNoneChaptersBtn" class="btn">å…¨ä¸é€‰</button>
							<button id="filterBtn" class="btn" style="margin-left: auto;">è¿‡æ»¤ ğŸ”</button>
						</div>
					</div>
				</div>

				<!-- This wrapper will now scroll -->
				<div id="chapter-list-wrapper">
					<ul id="chapter-list" class="info-list">
						<p class="placeholder-text">è¯·å…ˆé€‰æ‹©æˆ–ä¸Šä¼ å°è¯´</p>
					</ul>
				</div>
			</div>
		</div>

        <!-- Column 2: Character-Timbre Configuration -->
		<div class="content-column">
			<h2 class="column-header">è§’è‰²-éŸ³è‰²é…ç½®</h2>
			

			<div id="character-list" class="scrollable-content info-list">
				 <p class="placeholder-text">è¯·åœ¨å·¦ä¾§é€‰æ‹©ç« èŠ‚</p>
			</div>
			 <div class="column-footer" style="display:flex; justify-content: space-between;">
                 <!-- *** æ ¸å¿ƒä¿®æ”¹ 1: æ·»åŠ æ–°æŒ‰é’® *** -->
                 <button id="manageCharactersBtn" class="btn" disabled>è§’è‰²åç®¡ç†</button>
                 <button id="manageReplaceDictBtn" class="btn" disabled>ç®¡ç†æ›¿æ¢è¯å…¸</button>
				 <button id="saveConfigBtn" class="btn btn-primary" disabled>ä¿å­˜å½“å‰é…ç½®</button>
			 </div>
		</div>

		<!-- Column 3: Timbre Library -->
		<div class="content-column">
			<h2 class="column-header">
				<span>éŸ³è‰²åº“</span>
				<div class="controls" style="display: flex; align-items: center; gap: 0.5rem;">
					<select id="categoryFilter" style="font-size: 0.8rem; max-width: 150px;">
						<!-- JSåŠ¨æ€ç”Ÿæˆ -->
					</select>
				</div>
			</h2>
			<div id="timbre-list" class="scrollable-content info-list">
				<p class="placeholder-text">æ­£åœ¨åŠ è½½éŸ³è‰²...</p>
			</div>
			<div class="column-footer" style="display: flex; justify-content: space-between;">
				<button id="manageTimbresBtn" class="btn">ç®¡ç†éŸ³è‰²åº“</button>
				<button id="uploadTimbreLabelBtn" class="btn">ä¸Šä¼ æ–°éŸ³è‰²</button>
				<input type="file" id="timbreFile" accept="audio/*" style="display: none;">
			</div>
		</div>
		
		<!-- Column 4: Content Editor -->
		<div class="content-column">
			<h2 id="content-title" class="column-header">
				<span id="editor-title-text">å†…å®¹ç¼–è¾‘å™¨</span>
				<button id="chapterPlayStopBtn" class="btn" disabled style="margin-left: auto;">â–¶ï¸ æ’­æ”¾ç« èŠ‚</button>
			</h2>
			<div id="editor-view" class="scrollable-content">
				<p class="placeholder-text">è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€ä¸ªå·²å¤„ç†ç« èŠ‚ä»¥æ˜¾ç¤ºå†…å®¹ã€‚</p>
				<div id="raw-text-view" style="display: none;">
					<h4 id="raw-text-title" style="margin-top: 0;"></h4>
					<pre id="raw-text-content" class="scrollable-content" style="white-space: pre-wrap; word-wrap: break-word; font-family: 'Noto Sans SC', sans-serif; height: calc(100% - 30px); background-color: #f8f9fa; padding: 1rem; border-radius: 4px;"></pre>
				</div>
				<table class="content-table" style="display:none;">
					<thead>
						<tr>
							<th style="width: 3%;">æ“ä½œ</th> <!-- Adjusted width -->
							<th style="width: 4%;">#</th>
							<th style="width: 12%;">è§’è‰²</th>
							<th style="width: 15%;">éŸ³è‰²</th>
							<th>å†…å®¹</th>
							<th style="width: 12%;">TTSæ¨¡å‹</th> 
							<th style="width: 15%;">æ“ä½œ</th>
						</tr>
					</thead>
					<tbody id="content-table-body"></tbody>
				</table>
			</div>
			<div id="batch-view" class="scrollable-content" style="display: none; align-items: center; justify-content: center;">
				 <p class="placeholder-text" id="batch-view-message" style="font-size: 1.1rem;"></p>
			</div>
			<!-- NEW: Footer for save button -->
			<div class="column-footer" id="editor-footer" style="display: none;">
				<div style="display:flex; justify-content: space-between; align-items: center;">
					 <button id="addRowStartBtn" class="btn">æ·»åŠ æ–°è¡Œåˆ°é¦–è¡Œ</button>
					 <button id="saveChapterBtn" class="btn btn-primary" disabled>ä¿å­˜å¯¹æœ¬ç« èŠ‚çš„ä¿®æ”¹</button>
				</div>
			</div>
		</div>
    </main>
</div>

<!-- Modals -->
<div id="timbreUploadModal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-header">ä¸Šä¼ æ–°éŸ³è‰²</h3>
        <div class="input-group"><label for="newTimbreName">éŸ³è‰²åç§°</label><input type="text" id="newTimbreName"></div>
		<div class="input-group">
			<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
				<label for="newTimbreText" style="margin: 0;">å‚è€ƒæ–‡æœ¬</label>
                <div class="btn-group" style="display: flex; gap: 0.5rem; align-items: center;">
				    <button id="previewUploadBtn" class="audio-player-btn" title="è¯•å¬ä¸Šä¼ çš„éŸ³é¢‘" disabled style="width: 28px; height: 28px;">â–¶</button>
					<!-- é»˜è®¤éšè—è‡ªåŠ¨è¯†åˆ«æŒ‰é’® -->
					<button id="transcribeBtn" class="btn" disabled style="display: none;">è‡ªåŠ¨è¯†åˆ«</button>
                </div>
			</div>
			<textarea id="newTimbreText" rows="4"></textarea>
		</div>
		<div class="input-group">
			<label for="uploadTimbreCategory">é€‰æ‹©åˆ†ç±» (å¯é€‰)</label>
			<select id="uploadTimbreCategory">
				<option value="">-- ä¸å½’ç±» --</option>
			</select>
		</div>
        <div class="input-group"> <!-- å°†å…¶åŒ…è£…åœ¨ input-group ä¸­ï¼Œæ ·å¼æ›´ä¸€è‡´ -->
            <label for="normalizeVolume" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin-bottom: 0;">
                <span>éŸ³é‡æ ‡å‡†åŒ–</span>
                <input type="checkbox" id="normalizeVolume" checked style="width: auto; height: auto; margin-left: 0.5rem;">
            </label>
        </div>
        <div class="modal-actions"><button id="cancelUploadBtn" class="btn">å–æ¶ˆ</button><button id="confirmUploadBtn" class="btn btn-primary">ç¡®è®¤</button></div>
    </div>
</div>
<div id="profileModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="profileModalTitle" class="modal-header">è§’è‰²ç®€ä»‹</h3>
        <div id="profileModalBody">æ­£åœ¨åŠ è½½...</div>
        <div class="modal-actions"><button id="profileModalCloseBtn" class="btn">å…³é—­</button></div>
    </div>
</div><div id="globalSettingsModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 700px; padding: 0;">
        <div class="modal-header" style="padding: 1.5rem 2rem 1rem 2rem; border-bottom: 1px solid var(--border-color);">
            <h3 style="margin: 0;">å…¨å±€è®¾ç½®</h3>
        </div>

        <div class="settings-container">
            <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
            <nav class="settings-tabs">
                <button class="tab-link active" data-tab="tab-general">é€šç”¨è®¾ç½®</button>
                <button class="tab-link" data-tab="tab-models">LLMæ¨¡å‹é…ç½®</button>
				<button class="tab-link" data-tab="tab-tts">TTSæ¨¡å‹é…ç½®</button>
                <button class="tab-link" data-tab="tab-audio-export">éŸ³é¢‘å¯¼å‡º</button>
            </nav>

            <!-- å†…å®¹é¢æ¿ -->
            <div class="settings-content">
                <!-- é€šç”¨è®¾ç½®é¢æ¿ -->
                <div id="tab-general" class="tab-content active">
                    <fieldset style="border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;">
                        <legend style="font-weight: 500;">é»˜è®¤æ¨¡å‹</legend>
                        <div class="config-group">
                            <label for="settingsDefaultModel">å¤„ç†æ–°ç« èŠ‚æ—¶é»˜è®¤ä½¿ç”¨çš„æ¨¡å‹</label>
                            <select id="settingsDefaultModel">
                                <!-- é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                            </select>
                        </div>
                    </fieldset>
					<fieldset style="border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;">
						<legend style="font-weight: 500;">é»˜è®¤ TTSæ¨¡å‹</legend>
						<div class="config-group">
							<label for="settingsDefaultTtsModel">ç”Ÿæˆè¯­éŸ³æ—¶é»˜è®¤ä½¿ç”¨çš„ TTSæ¨¡å‹</label>
							<select id="settingsDefaultTtsModel">
								<!-- é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
							</select>
						</div>
					</fieldset>
                    <fieldset style="border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem;">
                        <legend style="font-weight: 500;">ä»£ç†æœåŠ¡å™¨ (Proxy)</legend>
                        <div class="config-group inline-group" style="margin-bottom: 1.5rem;">
                            <label for="settingsProxyEnabled">å¯ç”¨ä»£ç†</label>
                            <input type="checkbox" id="settingsProxyEnabled" style="width: auto; height: auto;">
                        </div>
                        <div id="proxy-details-group" style="display: none;">
                            <div class="config-group">
                                <label for="settingsProxyProtocol">åè®®</label>
                                <select id="settingsProxyProtocol">
                                    <option value="socks5h">SOCKS5 (socks5h)</option>
                                    <option value="http">HTTP</option>
                                    <option value="https">HTTPS</option>
                                </select>
                            </div>
                            <div class="config-group">
                                <label for="settingsProxyAddress">åœ°å€</label>
                                <input type="text" id="settingsProxyAddress" placeholder="e.g., 127.0.0.1">
                            </div>
                            <div class="config-group">
                                <label for="settingsProxyPort">ç«¯å£</label>
                                <input type="text" id="settingsProxyPort" placeholder="e.g., 1080">
                            </div>
                        </div>
                    </fieldset>
                </div>

                <!-- æ¨¡å‹é…ç½®é¢æ¿ -->
                <div id="tab-models" class="tab-content">
                    <p style="font-size: 0.85rem; color: var(--text-color-secondary); margin-top: 0; margin-bottom: 1.5rem;">
                        åœ¨æ­¤é…ç½®ç”¨äºå¤„ç†ç« èŠ‚çš„AIæ¨¡å‹çš„API Keyå’Œå‚æ•°ã€‚é…ç½®å°†ä¿å­˜åœ¨æœåŠ¡å™¨ã€‚
                    </p>
                    <div id="llmSettingsForm">
                        <p class="placeholder-text">æ­£åœ¨åŠ è½½é…ç½®...</p>
                    </div>
                </div>
				
				<div id="tab-tts" class="tab-content">
					<p style="font-size: 0.85rem; color: var(--text-color-secondary); margin-top: 0; margin-bottom: 1.5rem;">
						åœ¨æ­¤é…ç½®ç”¨äºç”Ÿæˆè¯­éŸ³çš„TTSï¼ˆæ–‡æœ¬è½¬è¯­éŸ³ï¼‰æœåŠ¡çš„åœ°å€å’Œæ˜¾ç¤ºåç§°ã€‚
					</p>
					<div id="ttsSettingsForm">
						<p class="placeholder-text">æ­£åœ¨åŠ è½½é…ç½®...</p>
					</div>
				</div>

                <!-- éŸ³é¢‘å¯¼å‡ºé¢æ¿ -->
                <div id="tab-audio-export" class="tab-content">
                    <div class="input-group">
                        <label for="exportFormat">éŸ³é¢‘æ ¼å¼</label>
                        <select id="exportFormat">
                            <option value="mp3">MP3</option>
                            <option value="wav">WAV</option>
                            <option value="m4a">M4A (AAC)</option>
                            <option value="ogg">OGG</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="exportQuality">éŸ³é¢‘è´¨é‡</label>
                        <select id="exportQuality"></select>
                    </div>
                </div>
            </div>
        </div>

        <div class="modal-actions" style="padding: 1rem 2rem 1.5rem 2rem; border-top: 1px solid var(--border-color); background-color: #f8f9fa;">
            <button id="globalSettingsCloseBtn" class="btn">å…³é—­</button>
            <button id="globalSettingsSaveBtn" class="btn btn-primary">ä¿å­˜å…¨éƒ¨è®¾ç½®</button>
        </div>
    </div>
</div>
<div id="filterModal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-header">ç« èŠ‚è¿‡æ»¤å™¨</h3>
        <div class="filter-options">
            <div class="filter-group">
                <fieldset>
                    <legend>æŒ‰çŠ¶æ€è¿‡æ»¤</legend>
                    <div class="radio-group">
                        <label><input type="radio" name="filterStatus" value="all" checked> æ˜¾ç¤ºå…¨éƒ¨</label>
                        <label><input type="radio" name="filterStatus" value="processed"> åªæ˜¾ç¤ºå·²å¤„ç†</label>
                        <label><input type="radio" name="filterStatus" value="unprocessed"> åªæ˜¾ç¤ºæœªå¤„ç†</label>
                    </div>
                </fieldset>
            </div>
            <div class="filter-group">
                 <fieldset>
                    <legend>æŒ‰èŒƒå›´è¿‡æ»¤ (åŸºäºåˆ—è¡¨é¡ºåº)</legend>
                    <div class="range-group">
                        <label for="rangeStart">ä»ç¬¬</label>
                        <input type="number" id="rangeStart" min="1" placeholder="èµ·å§‹">
                        <label for="rangeEnd">åˆ°ç¬¬</label>
                        <input type="number" id="rangeEnd" min="1" placeholder="ç»“æŸ">
                        <span>ç« </span>
                    </div>
                </fieldset>
            </div>
        </div>
        <div class="modal-actions">
            <button id="clearFilterBtn" class="btn">æ¸…é™¤è¿‡æ»¤</button>
            <button id="applyFilterBtn" class="btn btn-primary">åº”ç”¨è¿‡æ»¤</button>
        </div>
    </div>
</div>
<div id="dialogueModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <h3 id="dialogueModalTitle" class="modal-header">è§’è‰²å¯¹è¯é¢„è§ˆ</h3>
        <div id="dialogueModalBody" class="scrollable-content" style="max-height: 60vh; background-color: #f8f9fa; padding: 1rem; border-radius: var(--border-radius);">
            <!-- å¯¹è¯å†…å®¹å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
        </div>
        <div class="modal-actions">
            <button id="dialogueModalCloseBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<!-- NEW CHORAL EFFECT MODAL START -->
<div id="choralModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="choralModalTitle" class="modal-header">é€‰æ‹©å‚ä¸â€œå¤šäººåŒå£°â€çš„éŸ³è‰²</h3>
        <div id="choralTimbreList" class="scrollable-content" style="max-height: 50vh; border: 1px solid var(--border-color); padding: 0.5rem;">
            <!-- éŸ³è‰²åˆ—è¡¨å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
        </div>
        <div class="modal-actions">
            <button id="cancelChoralBtn" class="btn">å–æ¶ˆ</button>
            <button id="confirmChoralBtn" class="btn btn-primary">ç¡®è®¤ç”Ÿæˆ</button>
        </div>
    </div>
</div>
<!-- NEW CHORAL EFFECT MODAL END -->

<div id="replaceDictModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 700px; display: flex; flex-direction: column; height: 80vh;">
        <h3 class="modal-header">å°è¯´ä¸“å±æ›¿æ¢è¯å…¸ (<span id="replaceDictNovelName"></span>)</h3>
        <div class="replace-dict-body" style="flex-grow: 1; display: flex; flex-direction: column; overflow: hidden;">
            <div class="input-group" style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                <input type="text" id="newOriginalWord" class="form-control" placeholder="åŸè¯ (ä¾‹å¦‚: è¡Œé•¿)" style="flex: 1;">
                <input type="text" id="newReplacementWord" class="form-control" placeholder="æ›¿æ¢ä¸º (ä¾‹å¦‚: hangé•¿)" style="flex: 1;">
                <input type="text" id="newDescription" class="form-control" placeholder="æè¿° (å¯é€‰)" style="flex: 1;">
                <button id="addReplaceRuleBtn" class="btn btn-primary" style="flex-shrink: 0;">æ·»åŠ è§„åˆ™</button>
            </div>
            <div class="search-group" style="margin-bottom: 1rem;">
                <input type="text" id="replaceRuleSearchInput" class="form-control" placeholder="æœç´¢è§„åˆ™..." style="width: 100%;">
            </div>
            <div id="replaceRulesList" class="scrollable-content info-list" style="flex-grow: 1; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem;">
                <!-- æ›¿æ¢è§„åˆ™åˆ—è¡¨å°†åŠ¨æ€åŠ è½½åˆ°è¿™é‡Œ -->
                <p class="placeholder-text">æš‚æ— æ›¿æ¢è§„åˆ™</p>
            </div>
        </div>
        <div class="modal-actions" style="margin-top: 1rem;">
            <button id="closeReplaceDictBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<div id="deleteNovelModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 500px;">
        <h3 class="modal-header" style="color: var(--danger-color);">ç¡®è®¤æ°¸ä¹…åˆ é™¤</h3>
        <p>æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤å°è¯´é¡¹ç›® <strong id="novelToDeleteName"></strong> çš„æ‰€æœ‰ç›¸å…³æ–‡ä»¶ï¼ŒåŒ…æ‹¬ç« èŠ‚ã€é…ç½®å’Œå·²ç”Ÿæˆçš„éŸ³é¢‘æ–‡ä»¶ã€‚</p>
        <p>æ­¤æ“ä½œ**ä¸å¯æ’¤é”€**ã€‚</p>
        <div class="input-group">
            <label for="deleteConfirmInput">è¯·è¾“å…¥â€œ<b style="user-select: none;">åˆ é™¤</b>â€ä»¥ç¡®è®¤ï¼š</label>
            <input type="text" id="deleteConfirmInput" placeholder="åˆ é™¤">
        </div>
        <div class="modal-actions">
            <button id="cancelDeleteBtn" class="btn">å–æ¶ˆ</button>
            <button id="confirmDeleteBtn" class="btn btn-danger" disabled>ç¡®è®¤åˆ é™¤</button>
        </div>
    </div>
</div>

<div id="charManageModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 800px; display: flex; flex-direction: column; height: 80vh;">
        <h3 class="modal-header">è§’è‰²åç®¡ç†ä¸åˆå¹¶</h3>
        <div style="display: flex; flex-grow: 1; gap: 1rem; overflow: hidden;">
            <!-- Left Panel: Character List -->
            <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid var(--border-color); border-radius: 4px;">
                <div style="padding: 0.5rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
                    <input type="text" id="charSearchInput" placeholder="æœç´¢è§’è‰²å...">
                </div>
                <div id="charManageList" class="scrollable-content" style="padding: 0.5rem;">
                    <!-- Character list will be populated here -->
                </div>
            </div>
            <!-- Right Panel: Merge Controls -->
            <div style="flex: 1; display: flex; flex-direction: column; gap: 1rem;">
                <h4>åˆå¹¶é€‰ä¸­çš„è§’è‰²</h4>
                <div class="input-group">
                    <label>1. ä»¥ä¸‹è§’è‰²å°†è¢«åˆå¹¶ (è‡³å°‘é€‰æ‹©2ä¸ª):</label>
                    <div id="charsToMerge" style="min-height: 100px; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; background-color: #f8f9fa;"></div>
                </div>
                <div class="input-group">
                    <label for="targetCharSelect">2. é€‰æ‹©ä¸€ä¸ªä½œä¸ºä¸»è§’è‰²å:</label>
                    <select id="targetCharSelect" disabled></select>
                </div>
                <button id="confirmMergeBtn" class="btn btn-primary" disabled style="margin-top: auto;">ç¡®è®¤åˆå¹¶</button>
            </div>
        </div>
        <div class="modal-actions" style="margin-top: 1rem;">
            <button id="closeCharManageBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // === 1. STATE MANAGEMENT ===
    let state = {
        novelName: '', isTxtMode: false, txtChapters: [], selectedChapterPaths: [],
        characterMapping: {}, allTimbres: [], selectedCharacter: null, novelData: [],
        generatedFiles: {}, isProcessing: false, isProcessingCancelled: false,
		isTxtProcessing: false, isTxtProcessingCancelled: false, // 
        selectedLLM: 'gemini-2.5-flash',
		globalAudioPlayer: null, // ç”¨äºç« èŠ‚æ’­æ”¾
		simpleAudioPlayer: null, // ç”¨äºå•å¥å’ŒéŸ³è‰²è¯•å¬
		activeSimplePlayerButton: null, // è¿½è¸ªå½“å‰æ¿€æ´»çš„ç®€å•æ’­æ”¾æŒ‰é’®
        currentBlobURL: null, 
		allNovelsData: {}, 
		timbreDetails: {}, 
		fileToUpload: null,
        lastCheckedIndex: -1,
		globalConfig: {}, // stores the entire config from backend
        screenWakeLock: null, // 
		filter: {
			status: 'all', // 'all', 'processed', 'unprocessed'
			start: null,   // 1-based index
			end: null      // 1-based index
		},
        replaceDict: []// å°è¯´ä¸“å±æ›¿æ¢è§„åˆ™
    };
    const timbreColorClasses = ['timbre-color-1', 'timbre-color-2', 'timbre-color-3', 'timbre-color-4', 'timbre-color-5', 'timbre-color-6'];

    // === 2. DOM ELEMENTS ===
    const dom = {
        novelSelector: document.getElementById('novelSelector'), novelTxtFile: document.getElementById('novelTxtFile'),
        chapterListEl: document.getElementById('chapter-list'), selectAllChaptersBtn: document.getElementById('selectAllChaptersBtn'),
        selectNoneChaptersBtn: document.getElementById('selectNoneChaptersBtn'), processTxtBtn: document.getElementById('processTxtBtn'),
        characterListEl: document.getElementById('character-list'),
        saveConfigBtn: document.getElementById('saveConfigBtn'), timbreListEl: document.getElementById('timbre-list'),
        uploadTimbreLabelBtn: document.getElementById('uploadTimbreLabelBtn'), timbreFile: document.getElementById('timbreFile'),
        editorView: document.getElementById('editor-view'),
        contentTable: document.querySelector('.content-table'), contentTableBody: document.getElementById('content-table-body'),
        batchView: document.getElementById('batch-view'), batchViewMessage: document.getElementById('batch-view-message'),
        globalStatus: document.getElementById('global-status'), globalProgress: document.getElementById('global-progress'),
        globalProgressBar: document.getElementById('global-progress').querySelector('.progress-bar-inner'),
        processAllBtn: document.getElementById('processAllBtn'), 
		audioPlayerModal: document.getElementById('audioPlayerModal'),
		playerModalTitle: document.getElementById('playerModalTitle'),
		playerPlayPauseBtn: document.getElementById('playerPlayPauseBtn'),
		playerProgressBar: document.getElementById('playerProgressBar'),
		playerCurrentTime: document.getElementById('playerCurrentTime'),
		playerTotalDuration: document.getElementById('playerTotalDuration'),
		playerModalCloseBtn: document.getElementById('playerModalCloseBtn'),
        downloadSpliceBtn: document.getElementById('downloadSpliceBtn'), 
        timbreUploadModal: document.getElementById('timbreUploadModal'), newTimbreNameInput: document.getElementById('newTimbreName'),
        newTimbreTextInput: document.getElementById('newTimbreText'), cancelUploadBtn: document.getElementById('cancelUploadBtn'),
		transcribeBtn: document.getElementById('transcribeBtn'),
        previewUploadBtn: document.getElementById('previewUploadBtn'),
        confirmUploadBtn: document.getElementById('confirmUploadBtn'), profileModal: document.getElementById('profileModal'),
        profileModalTitle: document.getElementById('profileModalTitle'), profileModalBody: document.getElementById('profileModalBody'),
        profileModalCloseBtn: document.getElementById('profileModalCloseBtn'),
        settingsBtn: document.getElementById('settingsBtn'),
        exportFormat: document.getElementById('exportFormat'),
        exportQuality: document.getElementById('exportQuality'),
		saveChapterBtn: document.getElementById('saveChapterBtn'),
		addRowStartBtn: document.getElementById('addRowStartBtn'),
		filterBtn: document.getElementById('filterBtn'),
		filterModal: document.getElementById('filterModal'),
		applyFilterBtn: document.getElementById('applyFilterBtn'),
		clearFilterBtn: document.getElementById('clearFilterBtn'),
		rangeStartInput: document.getElementById('rangeStart'),
		rangeEndInput: document.getElementById('rangeEnd'),
        dialogueModal: document.getElementById('dialogueModal'),
        dialogueModalTitle: document.getElementById('dialogueModalTitle'),
        dialogueModalBody: document.getElementById('dialogueModalBody'),
        dialogueModalCloseBtn: document.getElementById('dialogueModalCloseBtn'),
        choralModal: document.getElementById('choralModal'),
        choralModalTitle: document.getElementById('choralModalTitle'),
        choralTimbreList: document.getElementById('choralTimbreList'),
        cancelChoralBtn: document.getElementById('cancelChoralBtn'),
        confirmChoralBtn: document.getElementById('confirmChoralBtn'),
        llmModelSelector: document.getElementById('llmModelSelector'),
        globalSettingsModal: document.getElementById('globalSettingsModal'),
        globalSettingsCloseBtn: document.getElementById('globalSettingsCloseBtn'),
        globalSettingsSaveBtn: document.getElementById('globalSettingsSaveBtn'),
        llmSettingsForm: document.getElementById('llmSettingsForm'),
		ttsSettingsForm: document.getElementById('ttsSettingsForm'),
        exportFormat: document.getElementById('exportFormat'),
        exportQuality: document.getElementById('exportQuality'),
        deleteNovelBtn: document.getElementById('deleteNovelBtn'),
        deleteNovelModal: document.getElementById('deleteNovelModal'),
        novelToDeleteName: document.getElementById('novelToDeleteName'),
        deleteConfirmInput: document.getElementById('deleteConfirmInput'),
        cancelDeleteBtn: document.getElementById('cancelDeleteBtn'),
        confirmDeleteBtn: document.getElementById('confirmDeleteBtn'),
        uploadTxtLabelBtn: document.getElementById('uploadTxtLabelBtn'),
        manageCharactersBtn: document.getElementById('manageCharactersBtn'),
        charManageModal: document.getElementById('charManageModal'),
        charSearchInput: document.getElementById('charSearchInput'),
        charManageList: document.getElementById('charManageList'),
        charsToMerge: document.getElementById('charsToMerge'),
        targetCharSelect: document.getElementById('targetCharSelect'),
        confirmMergeBtn: document.getElementById('confirmMergeBtn'),
        closeCharManageBtn: document.getElementById('closeCharManageBtn'),
		settingsDefaultModel: document.getElementById('settingsDefaultModel'),
		settingsProxyEnabled: document.getElementById('settingsProxyEnabled'),
		proxyDetailsGroup: document.getElementById('proxy-details-group'),
		settingsProxyProtocol: document.getElementById('settingsProxyProtocol'),
		settingsProxyAddress: document.getElementById('settingsProxyAddress'),
		settingsProxyPort: document.getElementById('settingsProxyPort'),
		settingsDefaultTtsModel: document.getElementById('settingsDefaultTtsModel'),
		editorTitleText: document.getElementById('editor-title-text'),
		chapterPlayStopBtn: document.getElementById('chapterPlayStopBtn'),
		manageTimbresBtn: document.getElementById('manageTimbresBtn'),
		timbresManageModal: document.getElementById('timbresManageModal'),
		closeTimbresManageBtn: document.getElementById('closeTimbresManageBtn'),
		managerCategoryList: document.getElementById('manager-category-list'),
		managerNewCategoryInput: document.getElementById('managerNewCategoryInput'),
		managerAddCategoryBtn: document.getElementById('managerAddCategoryBtn'),
		managerTimbresTitle: document.getElementById('manager-timbres-title'),
		managerTimbresList: document.getElementById('manager-timbres-list'),
		uploadTimbreCategory: document.getElementById('uploadTimbreCategory'),
        // Replace Dictionary Modal DOM elements
        manageReplaceDictBtn: document.getElementById('manageReplaceDictBtn'),
        replaceDictModal: document.getElementById('replaceDictModal'),
        replaceDictNovelName: document.getElementById('replaceDictNovelName'),
        newOriginalWord: document.getElementById('newOriginalWord'),
        newReplacementWord: document.getElementById('newReplacementWord'),
        newDescription: document.getElementById('newDescription'),
        addReplaceRuleBtn: document.getElementById('addReplaceRuleBtn'),
        replaceRuleSearchInput: document.getElementById('replaceRuleSearchInput'),
        replaceRulesList: document.getElementById('replaceRulesList'),
        closeReplaceDictBtn: document.getElementById('closeReplaceDictBtn')
    };

    // === 3. HELPER FUNCTIONS ===
    function playAudio(audioPath) {
        stopAllAudio(); // æ’­æ”¾å‰ç¡®ä¿åœæ­¢æ‰€æœ‰å…¶ä»–éŸ³é¢‘

        // æ³¨æ„ï¼šæˆ‘ä»¬ä»ç„¶ä½¿ç”¨ state.simpleAudioPlayer æ¥æ’­æ”¾ï¼Œ
        // è¿™æ · stopAllAudio ä¹Ÿèƒ½æ­£ç¡®åœ°åœæ­¢å®ƒã€‚
        state.simpleAudioPlayer = new Audio(`${audioPath}?t=${new Date().getTime()}`);
        
        const audio = state.simpleAudioPlayer;

        // ç»‘å®šå¿…è¦çš„äº‹ä»¶ï¼Œä»¥ä¾¿åœ¨æ’­æ”¾ç»“æŸæˆ–å‡ºé”™æ—¶æ¸…ç†è‡ªèº«
        const onEnded = () => {
            // æ’­æ”¾å®Œåï¼Œåªæ¸…ç†æ’­æ”¾å™¨å®ä¾‹ï¼Œä¸ç¢°ä»»ä½•UIæŒ‰é’®
            if (state.simpleAudioPlayer === audio) {
                state.simpleAudioPlayer = null;
            }
        };
        const onError = () => { setStatus(`æ’­æ”¾å¤±è´¥`, 'error'); onEnded(); };
        
        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onError);

        audio.play().catch(e => {
            if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
            onEnded();
        });
    }
	function formatTime(seconds) {
		const minutes = Math.floor(seconds / 60);
		const secs = Math.floor(seconds % 60);
		return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
	}
    // --- æ–°å¢ï¼šé˜²æ­¢å±å¹•ä¼‘çœ çš„è¾…åŠ©å‡½æ•° ---
    async function requestWakeLock() {
        if ('wakeLock' in navigator) {
            try {
                // å¦‚æœå·²å­˜åœ¨ä¸€ä¸ªé”ï¼Œå…ˆé‡Šæ”¾å®ƒ
                await releaseWakeLock();
                state.screenWakeLock = await navigator.wakeLock.request('screen');
                console.log('å±å¹•å”¤é†’é”å·²æ¿€æ´»ã€‚');
                setStatus('é•¿æ—¶é—´ä»»åŠ¡è¿›è¡Œä¸­ï¼Œå±å¹•å°†ä¿æŒå”¤é†’...', 'info');

                // ç›‘å¬é”çš„é‡Šæ”¾äº‹ä»¶ï¼Œä»¥é˜²æµè§ˆå™¨è‡ªåŠ¨é‡Šæ”¾ï¼ˆä¾‹å¦‚åˆ‡æ¢æ ‡ç­¾é¡µï¼‰
                state.screenWakeLock.addEventListener('release', () => {
                    console.log('å±å¹•å”¤é†’é”å·²è¢«æµè§ˆå™¨é‡Šæ”¾ã€‚');
                    state.screenWakeLock = null;
                });
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
                // å¿½ç•¥é”™è¯¯ï¼Œå› ä¸ºè¿™ä¸æ˜¯æ ¸å¿ƒåŠŸèƒ½
            }
        } else {
            console.warn('æµè§ˆå™¨ä¸æ”¯æŒ Screen Wake Lock APIã€‚');
        }
    }

    async function releaseWakeLock() {
        if (state.screenWakeLock !== null) {
            try {
                await state.screenWakeLock.release();
                state.screenWakeLock = null;
                console.log('å±å¹•å”¤é†’é”å·²é‡Šæ”¾ã€‚');
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }
    }
	
	function sanitizeTitleForFilename(title) {
		// This regex replaces any character that is NOT a letter, number, space, underscore, or hyphen.
		// We specifically keep Chinese characters by including the Unicode range \u4e00-\u9fa5.
		// The logic should perfectly match the Python backend's safe_title generation.
		// Python: "".join(c for c in title if c.isalnum() or c in " _-").rstrip()
		// JS equivalent is a bit more complex with regex to cover different languages.
		// A simpler regex that removes most problematic characters is often sufficient.
		
		// This simplified version removes common illegal characters for filenames.
		// It keeps letters (including Chinese), numbers, spaces, underscores, and hyphens.
		// It removes characters like ï¼ˆ, ï¼‰, ã€, ?, etc.
		return title.replace(/[^\p{L}\p{N}\s_-]/gu, '').trim();
	}
	function markChapterAsDirty() {
		dom.saveChapterBtn.disabled = false;
		setStatus('å†…å®¹å·²ä¿®æ”¹ï¼Œè¯·è®°å¾—ä¿å­˜ã€‚', 'warning');
	}
    function setStatus(msg, type = 'info') {
        dom.globalStatus.textContent = msg;
        const colorMap = { 'info': '#5f6368', 'success': '#1e8e3e', 'error': '#d93025', 'warning': '#f9ab00' };
        dom.globalStatus.style.color = colorMap[type];
    }
    async function fetchFromServer(url, options = {}) {
        const response = await fetch(url, options);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: response.statusText }));
            throw new Error(errorData.detail || `è¯·æ±‚å¤±è´¥: ${response.status}`);
        }
        return response.json();
    }
		
	function stopAllAudio(fromSimplePlayerClick = false) {
		// åœæ­¢ç« èŠ‚æ’­æ”¾å™¨
		if (state.globalAudioPlayer) {
			const audio = state.globalAudioPlayer;
			audio.pause();
			if (audio._listeners) {
				audio.removeEventListener('loadedmetadata', audio._listeners.onLoadedMetadata);
				audio.removeEventListener('timeupdate', audio._listeners.onTimeUpdate);
				audio.removeEventListener('play', audio._listeners.onPlay);
				audio.removeEventListener('pause', audio._listeners.onPause);
				audio.removeEventListener('ended', audio._listeners.onEnded);
				audio.removeEventListener('error', audio._listeners.onError);
			}
			state.globalAudioPlayer = null;
			dom.chapterPlayStopBtn.textContent = 'â–¶ï¸ æ’­æ”¾ç« èŠ‚';
			dom.audioPlayerModal.style.display = 'none';
		}

		// åœæ­¢ç®€å•æ’­æ”¾å™¨
		if (state.simpleAudioPlayer) {
            // æ£€æŸ¥ URL æ˜¯å¦ä¸º blob URLï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é‡Šæ”¾å®ƒä»¥é¿å…å†…å­˜æ³„æ¼
            if (state.simpleAudioPlayer.src && state.simpleAudioPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(state.simpleAudioPlayer.src);
            }
			state.simpleAudioPlayer.pause();
			if (state.simpleAudioPlayer._listeners) {
				 state.simpleAudioPlayer.removeEventListener('ended', state.simpleAudioPlayer._listeners.onEnded);
				 state.simpleAudioPlayer.removeEventListener('error', state.simpleAudioPlayer._listeners.onError);
			}
			state.simpleAudioPlayer = null;
		}

		// é‡ç½®ç®€å•æ’­æ”¾æŒ‰é’®çš„å›¾æ ‡
		if (state.activeSimplePlayerButton) {
			state.activeSimplePlayerButton.innerHTML = 'â–¶';
			state.activeSimplePlayerButton = null;
		}
	}
	
    function toggleLocalBlobAudio(button, file) {
        // è¿™ä¸ªå‡½æ•°ä¸“é—¨ç”¨äºå¤„ç†æœ¬åœ°æ–‡ä»¶é¢„è§ˆçš„æ’­æ”¾

        // æ­¥éª¤ 1: å¦‚æœå½“å‰æ­£åœ¨æ’­æ”¾çš„å°±æ˜¯è¿™ä¸ªæŒ‰é’®ï¼Œåˆ™åœæ­¢å®ƒ
        if (state.activeSimplePlayerButton === button) {
            stopAllAudio(); // stopAllAudio ä¼šå¤„ç†å›¾æ ‡é‡ç½®å’ŒéŸ³é¢‘åœæ­¢
            return;
        }

        // æ­¥éª¤ 2: åœæ­¢æ‰€æœ‰å…¶ä»–å¯èƒ½æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
        stopAllAudio();

        // æ­¥éª¤ 3: ä¸ºæœ¬åœ°æ–‡ä»¶åˆ›å»ºä¸€ä¸ªæ–°çš„ blob URL
        const localAudioURL = URL.createObjectURL(file);

        // æ­¥éª¤ 4: æ›´æ–°çŠ¶æ€å¹¶å¼€å§‹æ’­æ”¾
        state.activeSimplePlayerButton = button;
        button.innerHTML = 'â¹';

        state.simpleAudioPlayer = new Audio(localAudioURL); // ç›´æ¥ä½¿ç”¨ï¼Œä¸åŠ æ—¶é—´æˆ³
        const audio = state.simpleAudioPlayer;
        
        const onEnded = () => {
            URL.revokeObjectURL(localAudioURL); // åœ¨æ’­æ”¾ç»“æŸåé‡Šæ”¾ URL
            stopAllAudio();
        };
        const onError = () => {
            setStatus(`æ’­æ”¾å¤±è´¥`, 'error');
            URL.revokeObjectURL(localAudioURL); // å‡ºé”™æ—¶ä¹Ÿè¦é‡Šæ”¾ URL
            stopAllAudio();
        };
        
        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onError);
        audio._listeners = { onEnded, onError }; // è®°å½•ä¸‹æ¥ä»¥ä¾¿ stopAllAudio èƒ½ç§»é™¤

        audio.play().catch(e => {
            if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
            URL.revokeObjectURL(localAudioURL); // å‡ºé”™æ—¶ä¹Ÿè¦é‡Šæ”¾ URL
            stopAllAudio();
        });
    }

	/**
	 * æ–°åŠŸèƒ½ 1: æ’­æ”¾/åœæ­¢ ç« èŠ‚éŸ³é¢‘ (ç”±å†…å®¹ç¼–è¾‘å™¨æ ‡é¢˜æ æŒ‰é’®è§¦å‘)
	 */
	function toggleChapterAudio() {
		if (state.globalAudioPlayer) {
			stopAllAudio();
			return;
		}

		const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
		if (selectedCheckboxes.length === 1) {
			const checkbox = selectedCheckboxes[0];
			const chapterTitle = checkbox.dataset.title;
			const pathParts = checkbox.value.replace('.json', '').split(/[/\\]/);
			const novel = pathParts[0];
			const chapter = pathParts.length > 1 ? pathParts[1] : pathParts[0];
			const audioFormat = state.globalConfig.audio_export?.format || 'mp3';
			const audioPath = `/output/${novel}/${chapter}.${audioFormat}`;
			
			stopAllAudio();
			state.globalAudioPlayer = new Audio(`${audioPath}?t=${new Date().getTime()}`);
			const audio = state.globalAudioPlayer;

			dom.playerModalTitle.textContent = `æ­£åœ¨æ’­æ”¾: ${chapterTitle}`;
			dom.audioPlayerModal.style.display = 'flex';
			dom.chapterPlayStopBtn.textContent = 'â¹ åœæ­¢æ’­æ”¾';

			// --- å®Œæ•´çš„äº‹ä»¶å¤„ç†å™¨å®šä¹‰ ---
			const onLoadedMetadata = () => {
				dom.playerProgressBar.max = audio.duration;
				dom.playerTotalDuration.textContent = formatTime(audio.duration);
			};
			const onTimeUpdate = () => {
				dom.playerProgressBar.value = audio.currentTime;
				dom.playerCurrentTime.textContent = formatTime(audio.currentTime);
			};
			const onPlay = () => dom.playerPlayPauseBtn.innerHTML = 'â¸ï¸';
			const onPause = () => dom.playerPlayPauseBtn.innerHTML = 'â–¶ï¸';
			const onEnded = stopAllAudio;
			const onError = () => { setStatus(`æ— æ³•åŠ è½½éŸ³é¢‘`, 'error'); stopAllAudio(); };

			audio.addEventListener('loadedmetadata', onLoadedMetadata);
			audio.addEventListener('timeupdate', onTimeUpdate);
			audio.addEventListener('play', onPlay);
			audio.addEventListener('pause', onPause);
			audio.addEventListener('ended', onEnded);
			audio.addEventListener('error', onError);
			audio._listeners = { onLoadedMetadata, onTimeUpdate, onPlay, onPause, onEnded, onError };
			
			audio.play().catch(e => {
				if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
				stopAllAudio();
			});
		}
	}

	/**
	 * æ–°åŠŸèƒ½ 2: æ’­æ”¾/åœæ­¢ ç®€å•éŸ³é¢‘ (ç”±åœ†å½¢æŒ‰é’®è§¦å‘)
	 */
	function toggleSimpleAudio(button, audioPath) {
        // åœ¨å¼€å§‹æ’­æ”¾æ–°éŸ³é¢‘å‰ï¼Œæ£€æŸ¥å¹¶é‡Šæ”¾ä¸Šä¸€ä¸ª blob URL
        if (state.currentBlobURL) {
            URL.revokeObjectURL(state.currentBlobURL);
            state.currentBlobURL = null;
        }
		const isCurrentlyPlaying = state.activeSimplePlayerButton === button;

		// 1. æ— è®ºå¦‚ä½•ï¼Œå…ˆåœæ­¢æ‰€æœ‰å½“å‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ã€‚
		//    stopAllAudio() ä¼šè´Ÿè´£å°†æ—§çš„ activeSimplePlayerButton çš„å›¾æ ‡æ¢å¤ä¸º â–¶
		stopAllAudio();

		// 2. å¦‚æœåˆšæ‰ç‚¹å‡»çš„æŒ‰é’®å°±æ˜¯æ­£åœ¨æ’­æ”¾çš„é‚£ä¸ªï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ä»»åŠ¡åªæ˜¯åœæ­¢å®ƒï¼Œæ‰€ä»¥åˆ°æ­¤ä¸ºæ­¢ã€‚
		if (isCurrentlyPlaying) {
			return;
		}

		// 3. å¦åˆ™ï¼Œæˆ‘ä»¬è¦å¼€å§‹æ’­æ”¾æ–°çš„éŸ³é¢‘ã€‚
		state.activeSimplePlayerButton = button;
		button.innerHTML = 'â¹';

        // å¦‚æœæ˜¯ blob URLï¼Œåˆ™è®°å½•ä¸‹æ¥ä»¥ä¾¿åç»­é‡Šæ”¾
        if (audioPath.startsWith('blob:')) {
            state.currentBlobURL = audioPath;
        }
		state.simpleAudioPlayer = new Audio(`${audioPath}?t=${new Date().getTime()}`);
		const audio = state.simpleAudioPlayer;
		
		const onEnded = () => {
			// æ’­æ”¾å®Œåï¼Œè°ƒç”¨ stopAllAudio æ¥æ¸…ç†ä¸€åˆ‡å¹¶é‡ç½®UI
			stopAllAudio();
		};
		const onError = () => { setStatus(`æ’­æ”¾å¤±è´¥`, 'error'); stopAllAudio(); };
		
		audio.addEventListener('ended', onEnded);
		audio.addEventListener('error', onError);
		audio._listeners = { onEnded, onError };

		audio.play().catch(e => {
			if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
			stopAllAudio(); // å‡ºé”™æ—¶ä¹Ÿè¦æ¸…ç†
		});
	}
	
    function toBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }
    async function checkFileExists(filePath) {
		try {
			const response = await fetch(filePath, { method: 'HEAD', cache: 'no-store' });
			return response.ok;
		} catch (error) { return false; }
	}

    // === 4. CORE LOGIC & RENDERING ===

    async function loadNovels(shouldRender = true) { // å¢åŠ ä¸€ä¸ª shouldRender å‚æ•°
        try {
            const data = await fetchFromServer('/api/list_novels');
            state.allNovelsData = data.novels_details || {};

            if (shouldRender) { // åªæœ‰åœ¨éœ€è¦æ—¶æ‰é‡ç»˜ä¸‹æ‹‰æ¡†
                const currentNovel = dom.novelSelector.value; // ä¿å­˜å½“å‰é€‰ä¸­çš„å€¼

                dom.novelSelector.innerHTML = '<option value="">-- é€‰æ‹©å°è¯´é¡¹ç›® --</option>';
                Object.keys(state.allNovelsData).sort().forEach(novel => {
                    const option = document.createElement('option');
                    option.value = novel; option.textContent = novel;
                    dom.novelSelector.appendChild(option);
                });

                // å°è¯•æ¢å¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
                if (currentNovel && state.allNovelsData[currentNovel]) {
                    dom.novelSelector.value = currentNovel;
                }
            }
        } catch (e) { 
            setStatus(`åŠ è½½å°è¯´åˆ—è¡¨å¤±è´¥: ${e.message}`, 'error'); 
        }
    }
	
    async function handleTxtFileUpload(file) {
        if (!file) return;
        
        const novelName = file.name.replace(/\.txt$/i, '');
        setStatus(`æ­£åœ¨ä¸Šä¼ å¹¶åˆ†æå°è¯´: ${file.name}...`, 'info');
        
        // ç¦ç”¨UIé˜²æ­¢ç”¨æˆ·æ“ä½œ
        dom.novelSelector.disabled = true;
        dom.uploadTxtLabelBtn.disabled = true;

        const formData = new FormData();
        formData.append('file', file);

        try {
            // 1. ä¸Šä¼ æ–‡ä»¶ï¼Œå¹¶ç›´æ¥ä»åç«¯è·å–æ–°é¡¹ç›®çš„å®Œæ•´æ•°æ®ç»“æ„
            const newProjectData = await fetchFromServer('/api/upload_txt_novel', { 
                method: 'POST', 
                body: formData 
            });
            setStatus(newProjectData.message, 'success');

            // 2. æ›´æ–°å‰ç«¯ state
            //    a. å¢é‡æ›´æ–° allNovelsDataï¼ŒåŠ å…¥è¿™ä¸ªæ–°é¡¹ç›®
            //       åç«¯åº”è¯¥åœ¨ upload_txt_novel æˆåŠŸåï¼Œè¿”å›ç±»ä¼¼ list_novels ä¸­å•ä¸ªé¡¹ç›®çš„ç»“æ„
            //       ä¸ºäº†ç¡®ä¿ä¸‡æ— ä¸€å¤±ï¼Œæˆ‘ä»¬ç›´æ¥é‡æ–°åŠ è½½æ‰€æœ‰å°è¯´
            await loadNovels();

            // 3. æ›´æ–°UI
            //    a. é‡æ–°å¡«å……ä¸‹æ‹‰æ¡†ï¼ˆloadNovels å·²ç»åšäº†ï¼‰
            //    b. ä»¥ç¼–ç¨‹æ–¹å¼é€‰ä¸­æ–°ä¸Šä¼ çš„å°è¯´
            state.isProgrammaticChange = true; // ç«‹èµ·æ——å¸œï¼Œé˜²æ­¢ change äº‹ä»¶çš„å‰¯ä½œç”¨
            dom.novelSelector.value = novelName;
            
            // c. ã€æ ¸å¿ƒä¿®å¤ã€‘æ‰‹åŠ¨è°ƒç”¨ handleNovelSelection æ¥åŠ è½½æ–°é¡¹ç›®çš„å†…å®¹
            //    å› ä¸º isProgrammaticChange æ ‡å¿—ä¼šé˜»æ­¢ change äº‹ä»¶ç›‘å¬å™¨ä¸­çš„ handleNovelSelection æ‰§è¡Œ
            await handleNovelSelection(true); // ä¼ å…¥ä¸€ä¸ªå‚æ•°è¡¨ç¤ºè¿™æ˜¯ç”±ä¸Šä¼ è§¦å‘çš„

        } catch (error) {
            setStatus(`ä¸Šä¼ å¤±è´¥: ${error.message}`, 'error');
        } finally {
            // 4. æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½æ¢å¤UI
            dom.novelSelector.disabled = false;
            dom.uploadTxtLabelBtn.disabled = false;
        }
    }

	// å·®å¼‚ç‚¹ï¼šæä¾›å®Œæ•´çš„ã€åŒ…å«è¿‡æ»¤é€»è¾‘çš„ renderChapterList å‡½æ•°
	async function renderChapterList() {
		const listContainer = dom.chapterListEl;
		listContainer.innerHTML = '';
		state.lastCheckedIndex = -1;
		
        const novelName = state.novelName;
        const novelData = state.allNovelsData[novelName];
        
        // --- è¯Šæ–­æ¢é’ˆ 1 ---
        console.log(`[renderChapterList] Rendering for novel: ${novelName}`);
        if (novelData) {
            console.log(`[renderChapterList] Found novelData. isTxtProject is:`, novelData.isTxtProject);
        } else {
            console.warn(`[renderChapterList] No novelData found for ${novelName}!`);
        }
		
        const isTxtProject = novelData && novelData.isTxtProject === true;
		
		let originalChapters = [];

		if (novelData && novelData.chapters) {
            originalChapters = novelData.chapters.map((c, index) => ({ 
				path: isTxtProject ? c.id : `${novelName}/${sanitizeTitleForFilename(c.title)}.json`,
				name: c.title,
				originalIndex: index,
				processed: c.processed,
                spliced: c.spliced
			}));
		}

		const { status, start, end } = state.filter;
		let isFilterActive = status !== 'all' || (start && start.trim()) || (end && end.trim());
		let chaptersToRender = originalChapters;
		if (isFilterActive) {
			chaptersToRender = originalChapters.filter((chapter, index) => {
				const itemIndex = index + 1;
				if (status === 'processed' && !chapter.processed) return false;
				if (status === 'unprocessed' && chapter.processed) return false;
				const startRange = start ? parseInt(start, 10) : null;
				const endRange = end ? parseInt(end, 10) : null;
				if (startRange && itemIndex < startRange) return false;
				if (endRange && itemIndex > endRange) return false;
				return true;
			});
		}
		dom.filterBtn.classList.toggle('filter-btn-active', isFilterActive);

		if (chaptersToRender.length === 0) {
			dom.chapterListEl.innerHTML = '<p class="placeholder-text">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç« èŠ‚</p>';
		} else {
            let displayCounter = 1;
			chaptersToRender.forEach(chapter => {
				const li = document.createElement('li');
				li.className = `selectable ${chapter.processed ? 'processed' : ''} ${chapter.spliced ? 'spliced' : ''}`;
				
				const txtChapterAttribute = isTxtProject ? 'data-txt-chapter="true"' : '';
                
                // *** æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨è¿™é‡Œä¿®æ­£ checkbox value çš„ç”Ÿæˆé€»è¾‘ ***
                let checkboxValue;
                if (chapter.processed) {
                    // å¦‚æœç« èŠ‚å·²å¤„ç†ï¼Œæ— è®ºå®ƒæ¥è‡ªå“ªé‡Œï¼Œå®ƒçš„ "èº«ä»½" éƒ½åº”è¯¥æ˜¯ä¸€ä¸ª .json æ–‡ä»¶ã€‚
                    // å®ƒçš„è·¯å¾„åº”è¯¥æ˜¯æ ‡å‡†æ ¼å¼ã€‚
                    checkboxValue = `${novelName}/${sanitizeTitleForFilename(chapter.name)}.json`;
                } else {
                    // å¦‚æœç« èŠ‚æœªå¤„ç†ï¼Œæ‰åŒºåˆ†å®ƒæ¥è‡ªå“ªé‡Œã€‚
                    // å¦‚æœæ˜¯ TXT é¡¹ç›®ï¼Œå®ƒçš„è·¯å¾„å°±æ˜¯å®ƒçš„ IDã€‚
                    // å¦‚æœæ˜¯åŸç”Ÿé¡¹ç›®ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é¢„å…ˆç”Ÿæˆè·¯å¾„ï¼Œä½†è¿™ä¸å…³é”®ã€‚
                    checkboxValue = isTxtProject ? chapter.path : `${novelName}/${sanitizeTitleForFilename(chapter.name)}.json`;
                }
                
                // ä¸ºäº†ä¸ "å¤„ç†é€‰ä¸­ç« èŠ‚" æŒ‰é’®å…¼å®¹ï¼Œæœªå¤„ç†çš„TXTç« èŠ‚éœ€è¦ä¿ç•™ data-txt-chapter å±æ€§
                // åªæœ‰å½“å®ƒæ˜¯æœªå¤„ç†çš„TXTé¡¹ç›®æ—¶ï¼Œæ‰æ·»åŠ è¿™ä¸ªå±æ€§
                const finalTxtAttribute = isTxtProject ? 'data-txt-chapter="true"' : '';

				li.innerHTML = `<label style="display:flex; align-items:center; width:100%; cursor:pointer;">
                                    <input type="checkbox" class="chapter-checkbox" value="${checkboxValue}" data-index="${chapter.originalIndex}" data-title="${chapter.name}" ${txtChapterAttribute}> 
                                    <span class="label">
                                        <span style="display: inline-block; width: 3em; color: #9aa0a6; text-align: right; margin-right: 0.5rem;">${displayCounter}.</span>
                                        ${chapter.name}
                                    </span>
                                </label>`;
				
				listContainer.appendChild(li);
                displayCounter++; // è®¡æ•°å™¨é€’å¢
			});
		}
		updateGlobalButtons();
	}
        
    async function processTxtChapters() {
        if (state.isTxtProcessing) {
            state.isTxtProcessingCancelled = true;
            setStatus('ä¸­æ­¢æŒ‡ä»¤å·²å‘å‡ºï¼Œæ­£åœ¨ç­‰å¾…å½“å‰ç« èŠ‚å¤„ç†å®Œæˆ...', 'warning');
            updateGlobalButtons();
            return;
        }

        const chapterCheckboxesToProcess = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox[data-txt-chapter]:checked'));
        if (chapterCheckboxesToProcess.length === 0) {
            alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªTXTé¡¹ç›®çš„ç« èŠ‚è¿›è¡Œå¤„ç†ã€‚');
            return;
        }
		
        if (!state.selectedLLM) {
            alert('é”™è¯¯ï¼šæœªèƒ½è·å–åˆ°æœ‰æ•ˆçš„å¤„ç†æ¨¡å‹ã€‚è¯·ç¡®è®¤æ¨¡å‹å·²é€‰æ‹©æˆ–åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
            setStatus('å¤„ç†å¤±è´¥ï¼šæœªé€‰æ‹©å¤„ç†æ¨¡å‹ã€‚', 'error');
            return;
        }

        // --- æ–°å¢ï¼šç”¨æˆ·ç¡®è®¤é€»è¾‘ ---
        const chaptersToReprocess = chapterCheckboxesToProcess
            .filter(cb => cb.closest('li').classList.contains('processed'))
            .map(cb => cb.dataset.title);

        if (chaptersToReprocess.length > 0) {
            let confirmationMessage = '';
            const reprocessCount = chaptersToReprocess.length;
            const displayThreshold = 5;

            if (reprocessCount <= displayThreshold) {
                confirmationMessage = `ä»¥ä¸‹ç« èŠ‚å°†è¢«é‡æ–°å¤„ç†ï¼Œå¹¶åˆ é™¤å·²ç”Ÿæˆçš„è¯­éŸ³ï¼š\n\n- ${chaptersToReprocess.join('\n- ')}\n\næ‚¨ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`;
            } else {
                confirmationMessage = `æ‚¨é€‰ä¸­äº† ${reprocessCount} ä¸ªå·²è¢«å¤„ç†è¿‡çš„ç« èŠ‚ã€‚\n\nç»§ç»­æ“ä½œå°†æ°¸ä¹…åˆ é™¤è¿™äº›ç« èŠ‚å·²ç”Ÿæˆçš„æ‰€æœ‰è¯­éŸ³æ–‡ä»¶ã€‚\n\næ‚¨ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`;
            }

            if (!confirm(confirmationMessage)) {
                setStatus('æ“ä½œå·²å–æ¶ˆã€‚', 'info');
                return; // ç”¨æˆ·å–æ¶ˆï¼Œç»ˆæ­¢å‡½æ•°
            }
        }
        // --- ç”¨æˆ·ç¡®è®¤é€»è¾‘ç»“æŸ ---
        
        state.isTxtProcessing = true;
        state.isTxtProcessingCancelled = false;
        updateGlobalButtons();

        let processedCount = 0;
        const totalToProcess = chapterCheckboxesToProcess.length;
        
        try {
			await requestWakeLock(); // <-- æ–°å¢
            for (let i = 0; i < totalToProcess; i++) {
                if (state.isTxtProcessingCancelled) {
                    setStatus('å¤„ç†å·²ä¸­æ­¢ã€‚', 'warning');
                    break;
                }

                const checkbox = chapterCheckboxesToProcess[i];
                const chapterTitle = checkbox.dataset.title;
                const isReprocessing = chaptersToReprocess.includes(chapterTitle);

                setStatus(`[${i + 1}/${totalToProcess}] ${isReprocessing ? 'é‡æ–°' : ''}å¤„ç†ç« èŠ‚: ${chapterTitle}...`, 'info');

                try {
                    const payload = { 
                        novel_name: state.novelName, 
                        chapter_title: chapterTitle,
                        model_name: state.selectedLLM,
                        force_regenerate: isReprocessing // å‘åç«¯å‘é€ä¿¡å·
                    };
                    
                    await fetchFromServer('/api/process_single_chapter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    processedCount++;

                } catch (error) {
                    setStatus(`å¤„ç†ç« èŠ‚ "${chapterTitle}" å¤±è´¥: ${error.message}ã€‚å·²è·³è¿‡ã€‚`, 'error');
                    console.error(`[Process TXT] Error processing ${chapterTitle}:`, error);
                    continue;
                }
            }
        } finally {
			await releaseWakeLock(); // <-- æ–°å¢
            setStatus(`å¤„ç†ä»»åŠ¡ç»“æŸã€‚å…±æˆåŠŸå¤„ç† ${processedCount} / ${totalToProcess} ä¸ªç« èŠ‚ã€‚`, 'success');
            
            state.isTxtProcessing = false;
            state.isTxtProcessingCancelled = false;

            // åˆ·æ–°ç« èŠ‚åˆ—è¡¨å’ŒUI
            await loadNovels(); // ä½¿ç”¨å®Œæ•´çš„ loadNovels æ¥è·å–æœ€æ–°çŠ¶æ€
            const currentSelectedTitles = chapterCheckboxesToProcess.map(cb => cb.dataset.title);
            dom.novelSelector.value = state.novelName; // ç¡®ä¿ä¸‹æ‹‰æ¡†é€‰ä¸­å½“å‰å°è¯´
            await renderChapterList();
            
            // æ¢å¤å‹¾é€‰çŠ¶æ€
            dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => {
                if (currentSelectedTitles.includes(cb.dataset.title)) {
                    cb.checked = true;
                }
            });

            updateGlobalButtons();
            handleChapterSelectionChange();
        }
    }

    async function loadCharacters() {
        const chapterPaths = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked')).map(cb => cb.value);
        if (chapterPaths.length === 0) {
            dom.characterListEl.innerHTML = '<p class="placeholder-text">è¯·åœ¨å·¦ä¾§é€‰æ‹©ç« èŠ‚</p>';
            return;
        }
        dom.characterListEl.innerHTML = '<p class="placeholder-text">æ­£åœ¨åŠ è½½è§’è‰²...</p>';
        try {
            const chapterFiles = chapterPaths.map(path => path.split('/').pop());
            const payload = { novel_name: state.novelName, chapter_files: chapterFiles };
            const data = await fetchFromServer('/api/get_characters_in_chapters', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            renderCharacterList(data.characters);
        } catch (e) {
            setStatus(`åŠ è½½è§’è‰²å¤±è´¥: ${e.message}`, 'error');
            dom.characterListEl.innerHTML = `<p class="placeholder-text" style="color:var(--danger-color);">åŠ è½½è§’è‰²å¤±è´¥</p>`;
        }
    }

	async function renderCharacterList(characters) {
        dom.characterListEl.innerHTML = '';
        if (!characters || characters.length === 0) {
             dom.characterListEl.innerHTML = '<p class="placeholder-text">æ‰€é€‰ç« èŠ‚å†…æœªå‘ç°è§’è‰²</p>'; return;
        }
		
		// --- å¼‚æ­¥è·å–æ‰€æœ‰è§’è‰²çš„ç®€ä»‹ï¼Œä»¥ä¾¿åˆ¤æ–­æ˜¯å¦å®Œæ•´ ---
		const profilesResponse = await fetch(`/api/get_novel_details?novel_name=${state.novelName}`);
		const novelDetails = await profilesResponse.json();
		const characterProfiles = novelDetails.profiles || {};

        // *** æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨æ›´ç®€å•ã€æ›´å¯é çš„æ’åºé€»è¾‘ ***
        characters.sort((a, b) => {
            // ç›´æ¥æ£€æŸ¥ state.characterMapping[è§’è‰²å] æ˜¯å¦ä¸ºä¸€ä¸ªâ€œçœŸå€¼â€
            // çœŸå€¼æ„å‘³ç€å®ƒä¸æ˜¯ null, undefined, '', 0, falseã€‚
            // è¿™è¦†ç›–äº†æ‰€æœ‰â€œæœªåˆ†é…â€æˆ–â€œè¢«æ¸…ç©ºâ€çš„æƒ…å†µã€‚
            const a_has_timbre = !!state.characterMapping[a];
            const b_has_timbre = !!state.characterMapping[b];

            // å¦‚æœä¸¤è€…çš„åˆ†é…çŠ¶æ€ä¸åŒ
            if (a_has_timbre !== b_has_timbre) {
                // å¦‚æœ a æ²¡æœ‰éŸ³è‰² (false)ï¼Œb æœ‰ (true)ï¼Œé‚£ä¹ˆ a åº”è¯¥æ’åœ¨å‰é¢ã€‚
                // !a_has_timbre (true) - !b_has_timbre (false) = 1 (åœ¨JSä¸­å¸ƒå°”å€¼ä¼šè½¬ä¸ºæ•°å­—)
                // è¿™ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚ç›´æ¥ç”¨ if åˆ¤æ–­æ›´æ¸…æ™°ã€‚
                if (a_has_timbre) {
                    return 1; // a æœ‰ï¼Œb æ²¡æœ‰ï¼Œb åœ¨å‰
                } else {
                    return -1; // a æ²¡æœ‰ï¼Œb æœ‰ï¼Œa åœ¨å‰
                }
            }
            
            // å¦‚æœä¸¤è€…çŠ¶æ€ç›¸åŒï¼ˆéƒ½æœ‰æˆ–éƒ½æ²¡æœ‰ï¼‰ï¼Œåˆ™æŒ‰å­—æ¯é¡ºåºæ’åº
            return a.localeCompare(b);
        });
        
        // --- åç»­çš„æ¸²æŸ“é€»è¾‘ä¿æŒä¸å˜ ---

        const timbreUsageCount = {};
        characters.forEach(char => {
            const timbre = state.characterMapping[char];
            if (timbre) timbreUsageCount[timbre] = (timbreUsageCount[timbre] || 0) + 1;
        });
        const sharedTimbres = Object.keys(timbreUsageCount).filter(timbre => timbreUsageCount[timbre] > 1);
        const timbreToColorMap = {};
        sharedTimbres.forEach((timbre, index) => { timbreToColorMap[timbre] = timbreColorClasses[index % timbreColorClasses.length]; });

        characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'selectable character-row';
            li.dataset.characterName = char;
            if (char === state.selectedCharacter) li.classList.add('selected');
            
            const currentTimbre = state.characterMapping[char] || '---';
            if (currentTimbre === '---') {
                li.style.borderLeft = '3px solid var(--danger-color)'; // ç”¨å·¦è¾¹æ¡†é«˜äº®æœªåˆ†é…é¡¹
            }
            
            if (timbreToColorMap[currentTimbre]) li.classList.add(timbreToColorMap[currentTimbre]);
			
			let deepAnalyzeBtnHtml = '';
			const profile = characterProfiles[char];
			if (char !== 'æ—ç™½' && profile && (profile.gender === 'æœªçŸ¥' || profile.ageGroup === 'æœªçŸ¥')) {
				deepAnalyzeBtnHtml = `<button class="btn-deep-analyze" data-character-name="${char}" title="æ·±åº¦åˆ†æå¹¶è¡¥å…¨ä¿¡æ¯">ğŸ”</button>`;
			}
			
			const isNarrator = char === 'æ—ç™½'; // å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œæ–¹ä¾¿å¤ç”¨
			const profileBtnDisabled = isNarrator ? 'disabled' : ''; // å¦‚æœæ˜¯æ—ç™½ï¼Œåˆ™æ·»åŠ  disabled å±æ€§
            const isPlayable = !!state.characterMapping[char];
            const playableClass = isPlayable ? 'playable' : '';
			li.innerHTML = `<button class="btn btn-profile" data-character-name="${char}" title="${isNarrator ? 'æ—ç™½æ— éœ€ç®€ä»‹' : `æŸ¥çœ‹'${char}'ç®€ä»‹`}" ${profileBtnDisabled}>i</button>
						  ${deepAnalyzeBtnHtml}
						  <span class="label">${char}</span>
						  <div class="character-actions">
							<span class="value">${currentTimbre}</span>
							<button class="audio-player-btn ${playableClass}" title="è¯•å¬éŸ³è‰² ${currentTimbre}" style="visibility: ${state.characterMapping[char] ? 'visible' : 'hidden'};">â–¶</button>
						  </div>`;
            dom.characterListEl.appendChild(li);
        });
        updateRelatedRolesPopovers(); // åœ¨è¿™é‡Œè°ƒç”¨ï¼Œç¡®ä¿ DOM å·²æ›´æ–°
    }
    
	function updateRelatedRolesPopovers() {
		const isAnyChapterSelected = state.selectedChapterPaths.length > 0;

		let activeChapterCharacters = new Set();
		if (isAnyChapterSelected) {
			dom.characterListEl.querySelectorAll('.character-row .label').forEach(labelEl => {
				activeChapterCharacters.add(labelEl.textContent);
			});
		}
		const activeChapterCharacterArray = Array.from(activeChapterCharacters);

		dom.timbreListEl.querySelectorAll('li').forEach(li => {
			const timbreName = li.querySelector('.label')?.textContent;
			if (!timbreName) return;

			const popoverContainer = li.querySelector('.popover-container.roles-popover');
			if (!popoverContainer) return;

			const allAssignedRoles = Object.entries(state.characterMapping)
								  .filter(([char, timb]) => timb === timbreName)
								  .map(([char]) => char);
            
            const relevantAssignedRoles = allAssignedRoles.filter(role => 
                activeChapterCharacterArray.includes(role)
            );

			const popoverContentUl = popoverContainer.querySelector('.popover-content ul');
            
            if (isAnyChapterSelected && relevantAssignedRoles.length > 0) {
                popoverContainer.style.display = 'block';
				popoverContentUl.innerHTML = relevantAssignedRoles.map(c => `<li>${c}</li>`).join('');
            } else {
                popoverContainer.style.display = 'none';
                popoverContentUl.innerHTML = '';
            }
		});
	}
    
	async function loadAndApplyConfig() {
		dom.saveConfigBtn.disabled = true;
		setStatus(`æ­£åœ¨ä¸º "${state.novelName}" åŠ è½½éŸ³è‰²é…ç½®...`);
		try {
            // *** æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨URLä¸­æ·»åŠ ä¸€ä¸ªç¼“å­˜ç ´åè€…å‚æ•° ***
            const cacheBuster = `&_t=${new Date().getTime()}`;
			const url = `/api/get_config?novel_name=${state.novelName}${cacheBuster}`;

			// ä½¿ç”¨æ–°çš„URLæ¥è·å–æ•°æ®
			state.characterMapping = await fetchFromServer(url);
			setStatus(`é…ç½®åŠ è½½æˆåŠŸ`, 'success');
		} catch(e) {
			state.characterMapping = {};
			setStatus(`æœªæ‰¾åˆ°å°è¯´ "${state.novelName}" çš„é…ç½®ï¼Œå·²ä½¿ç”¨ç©ºé…ç½®ã€‚`, 'warning');
		} finally {
			await loadCharacters();
			dom.saveConfigBtn.disabled = !state.novelName;
		}
	}
    
	async function saveConfig() {
		if (!state.novelName) return;
		setStatus(`æ­£åœ¨ä¿å­˜é…ç½®åˆ° "${state.novelName}.json"...`);
		try {
			// The novel_name is now the sole identifier for the config
			const payload = { novel_name: state.novelName, config_data: state.characterMapping };
			const result = await fetchFromServer('/api/update_config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
			setStatus(result.message, 'success');
            updateRelatedRolesPopovers(); 
		} catch (e) { setStatus(`ä¿å­˜é…ç½®å¤±è´¥: ${e.message}`, 'error'); }
	}

    function showTimbreUploadModal(file) {
        state.fileToUpload = file;
        dom.newTimbreNameInput.value = file.name.split('.').slice(0, -1).join('.');
        dom.newTimbreTextInput.value = '';
        dom.timbreUploadModal.style.display = 'flex';
        dom.newTimbreNameInput.focus();
		dom.transcribeBtn.disabled = !file;
        dom.previewUploadBtn.disabled = !file; // æ ¹æ®æ–‡ä»¶æ˜¯å¦å­˜åœ¨æ¥å¯ç”¨/ç¦ç”¨æŒ‰é’®
    }
    function hideTimbreUploadModal() {
        stopAllAudio(); // ç¡®ä¿åœ¨å…³é—­æ—¶åœæ­¢ä»»ä½•æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
        dom.timbreUploadModal.style.display = 'none';
        state.fileToUpload = null;
        dom.previewUploadBtn.disabled = true; // å…³é—­åç¦ç”¨æŒ‰é’®
    }
	async function handleTimbreUpload() {
		if (!state.fileToUpload) return;
		const timbreName = dom.newTimbreNameInput.value.trim();
		const promptText = dom.newTimbreTextInput.value.trim();
		if (!timbreName || !promptText) {
			alert('éŸ³è‰²åç§°å’Œå‚è€ƒæ–‡æœ¬å‡ä¸èƒ½ä¸ºç©ºã€‚');
			return;
		}
		const normalize = document.getElementById('normalizeVolume').checked;
		const category = dom_timbres_manager.uploadCategorySelect.value; // è·å–åˆ†ç±»
		
		const formData = new FormData();
		formData.append('file', state.fileToUpload);
		formData.append('timbre_name', timbreName);
		formData.append('prompt_text', promptText);
		formData.append('normalize', normalize);
		formData.append('category_name', category); // å‘é€åˆ†ç±»

		setStatus(`æ­£åœ¨ä¸Šä¼ å¹¶å¤„ç†éŸ³è‰²: ${timbreName}... (æ­¤è¿‡ç¨‹å¯èƒ½éœ€è¦1-2åˆ†é’Ÿ)`, 'info');
		hideTimbreUploadModal();
		
		// UIåé¦ˆï¼šç¦ç”¨ä¸Šä¼ æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤æäº¤
		dom.uploadTimbreLabelBtn.disabled = true;
		dom.uploadTimbreLabelBtn.textContent = 'æ­£åœ¨å¤„ç†æ–°éŸ³è‰²...';

		try {
			const response = await fetch('/api/upload_timbre', {
				method: 'POST',
				body: formData
				// æ³¨æ„ï¼šä½¿ç”¨ FormData æ—¶ï¼Œæµè§ˆå™¨ä¼šè‡ªåŠ¨è®¾ç½® Content-Typeï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½®
			});
			
			const result = await response.json();
			if (response.ok) {
				setStatus(result.message, 'success');
				await loadTimbres();
			} else {
				throw new Error(result.detail || 'ä¸Šä¼ å¤„ç†å¤±è´¥');
			}

		} catch (error) {
			setStatus(`ä¸Šä¼ å¤±è´¥: ${error.message}`, 'error');
		} finally {
			// æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½æ¢å¤ä¸Šä¼ æŒ‰é’®
			dom.uploadTimbreLabelBtn.disabled = false;
			dom.uploadTimbreLabelBtn.textContent = 'ä¸Šä¼ æ–°éŸ³è‰²';
		}
	}
    
	async function handleChapterSelectionChange() {
        state.selectedChapterPaths = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked')).map(cb => cb.value);
        updateGlobalButtons();

        // æŸ¥æ‰¾æ‰€æœ‰ç›¸å…³çš„ DOM å…ƒç´ 
        const editorView = dom.editorView;
        const batchView = dom.batchView;
        const editorFooter = document.getElementById('editor-footer');
        const contentTable = dom.contentTable;
        const rawTextView = document.getElementById('raw-text-view');
        const rawTextTitle = document.getElementById('raw-text-title');
        const rawTextContent = document.getElementById('raw-text-content');

        // é€šç”¨æ¸…ç†
        editorView.style.display = 'none';
        batchView.style.display = 'none';
        contentTable.style.display = 'none';
        rawTextView.style.display = 'none';
        editorFooter.style.display = 'none';
        dom.editorTitleText.textContent = 'å†…å®¹ç¼–è¾‘å™¨';

        if (state.isProcessing || state.isTxtProcessing) {
            batchView.style.display = 'flex';
            dom.batchViewMessage.textContent = 'ä»»åŠ¡å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...';
            return;
        }
        
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');

        if (selectedCheckboxes.length === 1) {
            editorView.style.display = 'block';
            const checkbox = selectedCheckboxes[0];
            const chapterTitle = checkbox.dataset.title;
            const isProcessed = checkbox.closest('li').classList.contains('processed');
            const isTxtChapter = checkbox.hasAttribute('data-txt-chapter');

            // --- æ ¸å¿ƒé€»è¾‘åˆ†æ”¯ ---
            if (isProcessed) {
                // æƒ…å†µ Aï¼šå·²å¤„ç†ç« èŠ‚ -> æ˜¾ç¤ºè¡¨æ ¼ç¼–è¾‘å™¨
                contentTable.style.display = 'table';
                editorFooter.style.display = 'block';
                const filepath = checkbox.value;
                await loadSingleChapterForEditing(filepath);

            } else if (isTxtChapter) {
                // æƒ…å†µ Bï¼šæœªå¤„ç†çš„ TXT ç« èŠ‚ -> æ˜¾ç¤ºåŸæ–‡é¢„è§ˆ
                rawTextView.style.display = 'block';
                rawTextTitle.textContent = `åŸæ–‡é¢„è§ˆ: ${chapterTitle}`;
                rawTextContent.textContent = 'æ­£åœ¨åŠ è½½åŸæ–‡...';
                try {
                    const payload = {
                        novel_name: state.novelName,
                        chapter_title: chapterTitle,
                        preview_only: true
                    };
                    const result = await fetchFromServer('/api/process_single_chapter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (result.status === 'preview') {
						// ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å°†ä¸¤ä¸ªæˆ–æ›´å¤šçš„è¿ç»­æ¢è¡Œç¬¦ï¼Œæ›¿æ¢ä¸ºå•ä¸ªæ¢è¡Œç¬¦
						const formattedContent = result.content.replace(/(\r\n|\n|\r){2,}/g, '\n\n');
						rawTextContent.textContent = formattedContent;
                    } else {
                        throw new Error('åç«¯æœªè¿”å›é¢„è§ˆå†…å®¹ã€‚');
                    }
                } catch (error) {
                    rawTextContent.textContent = `åŠ è½½åŸæ–‡å¤±è´¥: ${error.message}`;
                }
                
            } else {
                // æƒ…å†µ Cï¼šå…¶ä»–æƒ…å†µï¼ˆä¾‹å¦‚ï¼Œæ—§ç‰ˆé¡¹ç›®æœªå¤„ç†çš„ç« èŠ‚ï¼‰ï¼Œæ˜¾ç¤ºæç¤º
                batchView.style.display = 'flex';
                dom.batchViewMessage.textContent = 'è¯·å…ˆåœ¨å·¦ä¾§å¤„ç†æ­¤ç« èŠ‚ã€‚';
            }
            // ---

        } else { // é€‰ä¸­ 0 ä¸ªæˆ–å¤šä¸ª
            batchView.style.display = 'flex';
            dom.batchViewMessage.textContent = selectedCheckboxes.length > 1 
                ? `å·²é€‰æ‹© ${selectedCheckboxes.length} ä¸ªç« èŠ‚ã€‚è¯·ä½¿ç”¨é¡¶éƒ¨å…¨å±€æŒ‰é’®è¿›è¡Œæ‰¹é‡æ“ä½œã€‚` 
                : `è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€ä¸ªç« èŠ‚ä»¥æ˜¾ç¤ºå†…å®¹ã€‚`;
        }
        
        // æ— è®ºå“ªç§æƒ…å†µï¼Œéƒ½éœ€è¦åŠ è½½è§’è‰²åˆ—è¡¨ï¼ˆå³ä½¿æ˜¯ç©ºçš„ï¼‰
        await loadCharacters();
	}
	
	// å·®å¼‚ç‚¹ï¼šåœ¨ loadSingleChapterForEditing å‡½æ•°ä¸­æ·»åŠ ç¼“å­˜ç ´åå‚æ•°
	async function loadSingleChapterForEditing(filepath) {
		setStatus(`æ­£åœ¨åŠ è½½ç« èŠ‚å†…å®¹...`);
		try {
			// --- æ ¸å¿ƒä¿®æ”¹å¼€å§‹ ---
			// Create a unique URL for each request to prevent caching.
			const cacheBuster = `&_t=${new Date().getTime()}`;
			const url = `/api/get_novel_content?filepath=${filepath}${cacheBuster}`;
			
			// Use the new URL to fetch data.
			state.novelData = await fetchFromServer(url);
			// --- æ ¸å¿ƒä¿®æ”¹ç»“æŸ ---
			
			await loadTimbres(); 

			state.generatedFiles = {};
			renderContentTable();
			await checkAllPlayableFiles();
		} catch (e) {
			setStatus(`åŠ è½½ç« èŠ‚å†…å®¹å¤±è´¥: ${e.message}`, 'error');
			state.novelData = [];
			renderContentTable();
		}
	}

	function renderContentTable() {
		const placeholder = dom.editorView.querySelector('.placeholder-text');
		const editorFooter = document.getElementById('editor-footer');

		if (state.novelData.length === 0) {
			dom.contentTable.style.display = 'none';
			placeholder.style.display = 'block';
			editorFooter.style.display = 'none';
			dom.contentTitle.textContent = 'å†…å®¹ç¼–è¾‘å™¨';
			return;
		}
		dom.contentTable.style.display = 'table';
		placeholder.style.display = 'none';
		editorFooter.style.display = 'block';
		dom.saveChapterBtn.disabled = true;
		
		const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
		const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
		dom.editorTitleText.textContent = `å†…å®¹ç¼–è¾‘å™¨: ${state.novelName} / ${currentChapterName}`;
		
		let ttsOptionsHtml = '';
		const ttsModels = state.globalConfig?.tts_models || {};
		const defaultTtsModel = state.globalConfig?.general?.default_tts_model || '';
		for (const modelId in ttsModels) {
			const model = ttsModels[modelId];
			const isSelected = modelId === defaultTtsModel ? 'selected' : '';
			ttsOptionsHtml += `<option value="${modelId}" ${isSelected}>${model.display_name || modelId}</option>`;
		}

		const isCosyVoiceDefault = defaultTtsModel.includes('cosyvoice');
		const modeSelectDisabledAttr = isCosyVoiceDefault ? '' : 'disabled';
		
		let tableHTML = '';
		state.novelData.forEach((item, index) => {
			const timbreOverride = item.timbre_override;
			const characterTimbre = state.characterMapping[item.speaker];
			const assignedTimbre = timbreOverride || characterTimbre;
			const isAssigned = !!assignedTimbre;

			// --- æ ¸å¿ƒä¿®æ”¹ 1: æ ¹æ®éŸ³è‰²æ˜¯å¦æœ‰æ•ˆï¼Œå†³å®šâ€œç”Ÿæˆâ€æŒ‰é’®çš„çŠ¶æ€ ---
			const generateBtnDisabled = isAssigned ? '' : 'disabled';

			let timbreSelectHtml = '';
			const timbreOptions = state.allTimbres.map(t => 
				`<option value="${t}" ${t === assignedTimbre ? 'selected' : ''}>${t}</option>`
			).join('');

			if (isAssigned) {
				let finalOptions = timbreOptions;
				if (!state.allTimbres.includes(assignedTimbre)) {
					finalOptions += `<option value="${assignedTimbre}" selected disabled class="placeholder-option">${assignedTimbre} (å·²ä¸¢å¤±)</option>`;
				}
				timbreSelectHtml = `<select class="timbre-override-select" data-row-index="${index}" style="width: 100%;">${finalOptions}</select>`;
			} else {
				timbreSelectHtml = `<select class="timbre-override-select" data-row-index="${index}" style="width: 100%;">
										<option value="" disabled selected class="placeholder-option">-- è¯·é€‰æ‹©éŸ³è‰² --</option>
										${timbreOptions}
									</select>`;
			}

			tableHTML += `<tr id="content-row-${index}">
				<td class="row-actions">
					<button class="btn btn-danger btn-delete-row" data-index="${index}" title="åˆ é™¤æ­¤è¡Œ">X</button>
					<button class="btn btn-insert-row" data-index="${index}" title="åœ¨æ­¤è¡Œä¸‹æ–¹æ’å…¥æ–°è¡Œ">+</button>
				</td>
				<td>${index + 1}</td>
				<td>${item.speaker}</td>
				<td>${timbreSelectHtml}</td>
				<td class="content-cell" contenteditable="true">${item.content}</td>
				<td>
					<select class="tts-model-select" style="width: 100%; padding: 0.3rem;">
						${ttsOptionsHtml}
					</select>
				</td>
				<td>
					<div class="actions-cell">
						<!-- ç¬¬ä¸€è¡Œ: ç”Ÿæˆ, æ’­æ”¾ -->
						<div class="action-row">
							<button class="btn btn-primary btn-generate" ${generateBtnDisabled}>ç”ŸæˆéŸ³é¢‘</button>
							<button class="btn-play audio-player-btn" title="æ’­æ”¾" disabled>â–¶</button>
						</div>

						<!-- ç¬¬äºŒè¡Œ: ç‰¹æ•ˆæŒ‰é’®, ä»¥åŠæ¨¡å¼/æŒ‡ä»¤çš„ç»„åˆ -->
						<div class="action-row">
							
							<!-- å·¦ä¾§: ç‰¹æ•ˆæŒ‰é’® -->
							<div class="popover-container">
								<button class="btn-effects" disabled>ç‰¹æ•ˆ</button>
								<div class="popover-content">
									<ul class="effects-menu">
										<li><button data-effect="reverb"><span>ğŸ”Š</span> å®¤å†…å›å£°</button></li>
										<li><button data-effect="phone"><span>ğŸ“</span> é€šè¯</button></li>
										<li><button data-effect="megaphone"><span>ğŸ“£</span> å–‡å­</button></li>
										<li style="border-top: 1px solid var(--border-color); margin-top: 0.25rem; padding-top: 0.25rem;"><button data-effect="choral"><span>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦</span> å¤šäººåŒå£°</button></li>
									</ul>
								</div>
							</div>

							<!-- å³ä¾§: æ¨¡å¼å’ŒæŒ‡ä»¤çš„å‚ç›´ç»„åˆå®¹å™¨ -->
							<div class="mode-instruct-group">
								<select class="mode-select" ${modeSelectDisabledAttr}>
									<option value="zero_shot" selected>æ™®é€š</option>
									<option value="cross_lingual">ç²¾ç»†</option>
									<option value="instruct">æŒ‡ä»¤</option>
								</select>
								<input type="text" class="instruct-input" placeholder="è¯·è¾“å…¥æŒ‡ä»¤ (ä¾‹å¦‚ï¼šç”¨å››å·è¯è¯´)">
							</div>

						</div>
					</div>
				</td>
			</tr>`;
		});
		dom.contentTableBody.innerHTML = tableHTML;
	}

    async function checkAllPlayableFiles() {
		if (state.novelData.length === 0 || state.selectedChapterPaths.length !== 1) return;
		setStatus('æ­£åœ¨æ£€æŸ¥å·²ç”Ÿæˆçš„æ–‡ä»¶...', 'info');
		let foundCount = 0;
		const path = state.selectedChapterPaths[0];
		const pathParts = path.replace('.json', '').split(/[/\\]/);
		const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];

		for(let i=0; i<state.novelData.length; i++) {
			const currentRow = document.getElementById(`content-row-${i}`);
			if (!currentRow) continue;
			
			const playBtn = currentRow.querySelector('.btn-play');
			const effectsBtn = currentRow.querySelector('.btn-effects');
			const speaker = state.novelData[i].speaker;
			
			// --- æ ¸å¿ƒä¿®æ”¹ï¼šä»ä¸‹æ‹‰æ¡†è·å–å½“å‰æœ€ç»ˆç¡®å®šçš„éŸ³è‰² ---
			const timbreSelect = currentRow.querySelector('.timbre-override-select');
			const timbre = timbreSelect ? timbreSelect.value : null;

			let fileExists = false;
			if (timbre) { // ä»…å½“éŸ³è‰²æœ‰æ•ˆæ—¶æ‰æ£€æŸ¥
				const expectedFileName = `${String(i).padStart(4, '0')}-${speaker}-${timbre}.wav`.replace(/[\\/:*?"<>|]/g, '_');
				const expectedFilePath = `/output/${state.novelName}/wavs/${currentChapterName}/${expectedFileName}`;
				
				if (await checkFileExists(expectedFilePath)) {
					fileExists = true;
					state.generatedFiles[i] = expectedFileName;
					foundCount++;
				}
			}
			
			// --- æ ¸å¿ƒä¿®æ”¹ï¼šæ ¹æ®æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œæ›´æ–°æŒ‰é’®çŠ¶æ€å’Œæ ·å¼ ---
			if (playBtn) {
				playBtn.disabled = !fileExists;
				if (fileExists) {
					playBtn.classList.add('playable'); // <-- æ·»åŠ  playable ç±»
				} else {
					playBtn.classList.remove('playable'); // <-- ç§»é™¤ playable ç±»
				}
			}
			if (effectsBtn) {
				effectsBtn.disabled = !fileExists;
			}
		}
		setStatus(`æ£€æŸ¥å®Œæ¯•ï¼Œæ‰¾åˆ° ${foundCount} ä¸ªåŒ¹é…æ–‡ä»¶ã€‚`, 'success');
	}
        
    async function loadTimbreDetails(name) {
        if (state.timbreDetails[name]) return Promise.resolve(state.timbreDetails[name]);
        try {
            const encodedName = encodeURIComponent(name);
            const [audioResponse, textResponse] = await Promise.all([
                fetch(`/wav/${encodedName}/1.wav`),
                fetch(`/wav/${encodedName}/1.txt`)
            ]);
            if (!audioResponse.ok || !textResponse.ok) throw new Error(`éŸ³è‰²'${name}'çš„æ–‡ä»¶ä¸å®Œæ•´`);
            const promptAudio = await toBase64(await audioResponse.blob());
            const promptText = await textResponse.text();
            const details = { promptAudio, promptText };
            state.timbreDetails[name] = details;
            return details;
        } catch (e) {
            setStatus(`åŠ è½½éŸ³è‰²'${name}'è¯¦æƒ…å¤±è´¥: ${e.message}`, 'error');
            throw e;
        }
    }

    // 2. generateSpeech(payload)
    async function generateSpeech(payload) {
        // *** æ ¸å¿ƒä¿®æ”¹ 1: å®ç°é‡è¯•é€»è¾‘ ***
        const MAX_RETRIES = 3; // 1æ¬¡åˆæ¬¡å°è¯• + 2æ¬¡é‡è¯•
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                // Note: This function now expects the payload to already contain prompt_audio and prompt_text
                const result = await fetchFromServer('/api/tts_v2', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (result.status === 'success') {
                    // å¦‚æœæˆåŠŸï¼Œç«‹å³è¿”å›æ–‡ä»¶å
                    return result.file_name;
                } else {
                    // å¦‚æœAPIè¿”å›äº†ä¸€ä¸ªå·²çŸ¥çš„é”™è¯¯çŠ¶æ€ï¼Œä¹Ÿè§†ä¸ºå¤±è´¥
                    throw new Error(result.message || 'API returned a non-success status.');
                }
            } catch (error) {
                const errorMessage = `ç”Ÿæˆå¤±è´¥ (è¡Œ: ${payload.row_index + 1}, å°è¯•: ${attempt}/${MAX_RETRIES}): ${error.message}`;
                setStatus(errorMessage, 'error');
                console.error(errorMessage, error);

                if (attempt === MAX_RETRIES) {
                    // å¦‚æœè¿™æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œåˆ™æ”¾å¼ƒå¹¶è¿”å› null
                    setStatus(`å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè·³è¿‡æ­¤è¡Œã€‚`, 'warning');
                    return null;
                }
                
                // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´å†é‡è¯•
                await new Promise(resolve => setTimeout(resolve, 2000)); // ç­‰å¾…2ç§’
            }
        }
        return null; // ç†è®ºä¸Šä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼Œä½†ä½œä¸ºå®‰å…¨ä¿éšœ
    }
	
	async function processAllAndSplice() {
		if (state.isProcessing) {
			state.isProcessingCancelled = true;
			setStatus('ä¸­æ­¢æŒ‡ä»¤å·²å‘å‡ºï¼Œæ­£åœ¨ç­‰å¾…å½“å‰ä»»åŠ¡å®Œæˆ...', 'warning');
            updateGlobalButtons();
			return;
		}

		const chaptersToProcess = state.selectedChapterPaths.filter(path => path.includes('.json'));
		if (chaptersToProcess.length === 0) {
			setStatus("æ²¡æœ‰å·²å¤„ç†çš„ç« èŠ‚è¢«é€‰ä¸­ï¼Œæ— æ³•ç”Ÿæˆã€‚", "warning");
			return;
		}

		state.isProcessing = true;
		state.isProcessingCancelled = false;
		updateGlobalButtons();
		dom.globalProgress.style.display = 'block';
		dom.globalProgressBar.style.width = '0%';
		
		const totalChapters = chaptersToProcess.length;
		let chaptersProcessed = 0;
        let successfullySplicedChapters = [];

		try {
			await requestWakeLock(); // <-- æ–°å¢
			for (const chapterPath of chaptersToProcess) {
				if (state.isProcessingCancelled) { setStatus(`å¤„ç†å·²ä¸­æ­¢...`, 'warning'); break; }
				
				const pathParts = chapterPath.replace('.json', '').split(/[/\\]/);
				const currentNovelName = pathParts[0];
				const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
				
				setStatus(`[${chaptersProcessed + 1}/${totalChapters}] åŠ è½½ç« èŠ‚: ${currentChapterName}...`);

				const chapterData = await fetchFromServer(`/api/get_novel_content?filepath=${encodeURIComponent(chapterPath)}`);

				const filesToSplice = [];
				const totalRows = chapterData.length;
                let chapterGenerationOk = true; // æœ¬ç« èŠ‚ç”ŸæˆçŠ¶æ€æ ‡å¿—

				for (let i = 0; i < totalRows; i++) {
					if (state.isProcessingCancelled) { setStatus(`å¤„ç†å·²ä¸­æ­¢...`, 'warning'); break; }
					
					const progress = ((chaptersProcessed / totalChapters) + ((i + 1) / totalRows) / totalChapters) * 100 * 0.9;
					dom.globalProgressBar.style.width = `${progress}%`;
					setStatus(`[${chaptersProcessed + 1}/${totalChapters}] ${currentChapterName}: å¤„ç†ä¸­ ${i + 1}/${totalRows}...`);

					const item = chapterData[i];
                    
                    // --- æ ¸å¿ƒæ™ºèƒ½åˆ¤æ–­é€»è¾‘ ---
                    // 1. ä¼˜å…ˆä½¿ç”¨è¡Œå†…æŒ‡å®šçš„ `timbre_override` éŸ³è‰²
                    let timbre_to_use = item.timbre_override;

                    // 2. å¦‚æœæ²¡æœ‰è¡Œå†…æŒ‡å®šï¼Œåˆ™å›é€€åˆ°ä½¿ç”¨è§’è‰²çš„å…¨å±€é…ç½®éŸ³è‰²
                    if (!timbre_to_use) {
                        timbre_to_use = state.characterMapping[item.speaker];
                    }

                    // 3. å¦‚æœä¸¤ç§æ–¹å¼éƒ½æ‰¾ä¸åˆ°éŸ³è‰²ï¼Œåˆ™æ ‡è®°æœ¬ç« ä¸ºå¤±è´¥å¹¶ä¸­æ–­
					if (!timbre_to_use) { 
                        setStatus(`é”™è¯¯: è§’è‰²'${item.speaker}'åœ¨ç¬¬ ${i+1} è¡Œæœªåˆ†é…ä»»ä½•éŸ³è‰²ï¼Œå·²è·³è¿‡æœ¬ç« èŠ‚ã€‚`, 'error');
                        chapterGenerationOk = false;
                        break; 
                    }
                    
                    // --- åç»­æ‰€æœ‰é€»è¾‘ï¼Œéƒ½ä½¿ç”¨ timbre_to_use ---
                    const currentTimbre = timbre_to_use;
					const expectedFileName = `${String(i).padStart(4, '0')}-${item.speaker}-${currentTimbre}.wav`.replace(/[\\/:*?"<>|]/g, '_');
					const expectedFilePath = `/output/${currentNovelName}/wavs/${currentChapterName}/${expectedFileName}`;
					
					if (await checkFileExists(expectedFilePath)) {
						filesToSplice.push(expectedFileName);
					} else {
						const payload = {
							novel_name: currentNovelName, 
                            chapter_name: currentChapterName, 
                            row_index: i, 
							speaker: item.speaker, 
                            timbre: currentTimbre, 
                            tts_text: item.content,
							inference_mode: item.inference_mode || 'zero_shot', 
							instruct_text: item.instruct_text || ''          
						};
						const details = await loadTimbreDetails(currentTimbre);
						payload.prompt_audio = details.promptAudio;
						payload.prompt_text = details.promptText;
						
                        const generatedFile = await generateSpeech(payload);
						
                        if (generatedFile) {
                            filesToSplice.push(generatedFile);
                        } else {
                            setStatus(`ç« èŠ‚ "${currentChapterName}" ç¬¬ ${i + 1} è¡Œç”Ÿæˆå¤±è´¥ï¼Œå·²è·³è¿‡æœ¬ç« èŠ‚çš„åç»­å¤„ç†ã€‚`, 'error');
                            chapterGenerationOk = false;
                            break;
                        }
					}
				}
				if (state.isProcessingCancelled) break;

                // æ‹¼æ¥å‰çš„å®Œæ•´æ€§æ£€æŸ¥é€»è¾‘ä¿æŒä¸å˜
				if (chapterGenerationOk) {
                    setStatus(`[${chaptersProcessed + 1}/${totalChapters}] ${currentChapterName}: æ‰€æœ‰éŸ³é¢‘å·²å°±ç»ªï¼Œæ­£åœ¨æ‹¼æ¥...`);
                    const splicePayload = { 
                        novel_name: currentNovelName, 
                        chapter_name: currentChapterName, 
                        wav_files: filesToSplice
                    };
                    const result = await fetchFromServer('/api/splice_audio', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(splicePayload) });
                    if (result.status !== 'success') throw new Error(result.message || "æ‹¼æ¥å¤±è´¥");
                    
                    setStatus(`[${chaptersProcessed + 1}/${totalChapters}] ç« èŠ‚ "${currentChapterName}" å¤„ç†å®Œæˆ!`, 'success');
                    chaptersProcessed++;
                    successfullySplicedChapters.push(currentChapterName);
                } else {
                    console.warn(`Skipping splice for ${currentChapterName} due to generation failures or cancellation.`);
                }
			}
		} catch(error) {
			setStatus(`æ‰¹é‡å¤„ç†å¤±è´¥: ${error.message}`, 'error');
		} finally {
			await releaseWakeLock(); // <-- æ–°å¢
            // finally å—ä¸­çš„å…¶ä»–ä»£ç ä¿æŒä¸å˜...
			state.isProcessing = false;
			state.isProcessingCancelled = false;
			
            if (!state.isProcessingCancelled && chaptersProcessed === totalChapters && totalChapters > 0) {
				 setStatus('æ‰€æœ‰é€‰å®šç« èŠ‚å·²å¤„ç†å®Œæˆï¼', 'success');
				 dom.globalProgressBar.style.width = '100%';
			}

            if (successfullySplicedChapters.length > 0 || state.isProcessingCancelled) {
                setStatus('å¤„ç†ç»“æŸ', 'info');
                const currentNovel = dom.novelSelector.value; // 1. ä¿å­˜å½“å‰é€‰æ‹©
                await loadNovels(false); // 2. è°ƒç”¨ loadNovelsï¼Œä½†ä¼ å…¥ falseï¼Œåªæ›´æ–° state æ•°æ®
                renderChapterList();  // 3. ç”¨æ–°æ•°æ®é‡æ–°æ¸²æŸ“ç« èŠ‚åˆ—è¡¨
                // const currentNovelName = dom.novelSelector.value; // è¿™å¥ä¸å†éœ€è¦
                dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => {
                    const cbNovel = cb.value.split('/')[0];
                    if (cbNovel === currentNovel && state.selectedChapterPaths.includes(cb.value)) {
                        cb.checked = true;
                    }
                });
            }

            updateGlobalButtons();
			setTimeout(() => { dom.globalProgress.style.display = 'none'; }, 5000);
		}
	}
	
    // 4. showProfileModal(characterName)
    async function showProfileModal(characterName) {
        dom.profileModalTitle.textContent = `è§’è‰²ç®€ä»‹: ${characterName}`;
        dom.profileModalBody.innerHTML = 'æ­£åœ¨åŠ è½½...';
        dom.profileModal.style.display = 'flex';
        try {
            const encodedCharName = encodeURIComponent(characterName);
            const data = await fetchFromServer(`/api/get_character_profile?novel_name=${state.novelName}&character_name=${encodedCharName}`);
            let html = '<dl>';
            html += `<dt>æ€§åˆ«</dt><dd>${data.gender || 'æœªçŸ¥'}</dd>`;
            html += `<dt>å¹´é¾„æ®µ</dt><dd>${data.ageGroup || 'æœªçŸ¥'}</dd>`;
            html += `<dt>èº«ä»½</dt><dd>${data.identity || 'æœªçŸ¥'}</dd>`;
            html += '</dl>';
            dom.profileModalBody.innerHTML = html;
        } catch (error) {
            dom.profileModalBody.textContent = `åŠ è½½ç®€ä»‹å¤±è´¥: ${error.message}`;
        }
    }

    // 5. qualityOptions object
    const qualityOptions = {
        mp3: ['128k', '192k', '256k', '320k'],
        wav: ['æ— æŸ (PCM 16-bit)'],
        m4a: ['128k', '192k', '256k'],
        ogg: ['q5 (çº¦160k)', 'q7 (çº¦224k)', 'q9 (çº¦320k)']
    };

    // 6. updateQualityOptions()
	function updateQualityOptions() {
		const format = dom.exportFormat.value;
		const qualities = qualityOptions[format];
		dom.exportQuality.innerHTML = '';
		qualities.forEach(q => {
			const option = document.createElement('option');
			const value = (format === 'ogg') ? q.split(' ')[0] : (format === 'wav' ? 'pcm_s16le' : q);
			option.value = value;
			option.textContent = q;
			dom.exportQuality.appendChild(option);
		});
		dom.exportQuality.disabled = (format === 'wav');

		// --- æ ¸å¿ƒä¿®å¤ ---
		// ä» state.globalConfig.audio_export è¯»å–æ•°æ®ï¼Œè€Œä¸æ˜¯æ—§çš„ state.exportSettings
		// åŒæ—¶å¢åŠ å¥å£®æ€§æ£€æŸ¥ï¼Œé˜²æ­¢ state.globalConfig è¿˜æœªåŠ è½½æ—¶å‡ºé”™
		const audioExportConfig = state.globalConfig?.audio_export;
		if (audioExportConfig && audioExportConfig.format === format) {
			dom.exportQuality.value = audioExportConfig.quality;
		} else {
			// å¦‚æœæ ¼å¼ä¸åŒ¹é…æˆ–é…ç½®ä¸å­˜åœ¨ï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
			dom.exportQuality.selectedIndex = 0;
		}
	}
    
    
	function updateGlobalButtons() {
		const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
		const selectedCount = selectedCheckboxes.length;
		
		 // --- æŒ‰é’®çŠ¶æ€çš„ç»Ÿä¸€æ§åˆ¶ ---

		 // A. ç­›é€‰å‡ºä¸åŒç±»å‹çš„é€‰ä¸­é¡¹
		 const processableTxtCheckboxes = Array.from(selectedCheckboxes).filter(cb => {
			 return cb.hasAttribute('data-txt-chapter');
		 });
		 const processableTxtCount = processableTxtCheckboxes.length;
		 
		 const processableJsonCheckboxes = Array.from(selectedCheckboxes).filter(cb => cb.value.includes('.json'));
		 const processableJsonCount = processableJsonCheckboxes.length;
		 
		 // B. æ§åˆ¶ â€œå¤„ç†æ–‡æœ¬â€ æŒ‰é’®
		 if (state.isTxtProcessing) {
			 dom.processTxtBtn.textContent = 'åœæ­¢å¤„ç†';
			 dom.processTxtBtn.classList.add('btn-danger');
			 dom.processTxtBtn.disabled = state.isTxtProcessingCancelled; 
			 if (state.isTxtProcessingCancelled) {
				 dom.processTxtBtn.textContent = 'æ­£åœ¨åœæ­¢...';
			 }
		 } else {
			 dom.processTxtBtn.textContent = `å¤„ç†æ–‡æœ¬ (${processableTxtCount})`;
			 dom.processTxtBtn.classList.remove('btn-danger');
			 dom.processTxtBtn.disabled = processableTxtCount === 0 || state.isProcessing;
		 }
		
		// C. æ§åˆ¶ â€œç”Ÿæˆå£°éŸ³â€ æŒ‰é’®
		if (state.isProcessing) {
			dom.processAllBtn.textContent = 'åœæ­¢ç”Ÿæˆ';
			dom.processAllBtn.classList.remove('btn-primary');
			dom.processAllBtn.classList.add('btn-danger');
			dom.processAllBtn.disabled = state.isProcessingCancelled; 
			 if (state.isProcessingCancelled) {
				 dom.processAllBtn.textContent = 'æ­£åœ¨åœæ­¢...';
			 }
		} else {
			dom.processAllBtn.textContent = `ç”Ÿæˆè¯­éŸ³ (${processableJsonCount})`;
			dom.processAllBtn.classList.remove('btn-danger');
			dom.processAllBtn.classList.add('btn-primary');
			dom.processAllBtn.disabled = processableJsonCount === 0 || state.isTxtProcessing;
		}

		 // D. æ§åˆ¶ â€œä¸‹è½½å£°éŸ³â€ æŒ‰é’®
		 let hasSplicedChapter = false;
		 if (state.novelName && state.allNovelsData[state.novelName] && !state.isProcessing && !state.isTxtProcessing) {
			 const novelChapters = state.allNovelsData[state.novelName].chapters;
			 for (const checkbox of selectedCheckboxes) {
				 const chapterTitle = checkbox.dataset.title;
				 const chapterData = novelChapters.find(c => c.title === chapterTitle);
				 if (chapterData && chapterData.spliced) {
					 hasSplicedChapter = true;
					 break;
				 }
			 }
		 }
		 dom.downloadSpliceBtn.disabled = state.isProcessing || state.isTxtProcessing || !hasSplicedChapter;
		 
		 // E. æ§åˆ¶ â€œæ’­æ”¾å£°éŸ³â€ æŒ‰é’®
		let canPlayChapter = false;
		if (selectedCount === 1) {
			const checkbox = selectedCheckboxes[0];
			if (checkbox.closest('li').classList.contains('spliced')) {
				canPlayChapter = true;
			}
		}
		dom.chapterPlayStopBtn.disabled = !canPlayChapter;


		 // F. å…¨å±€å¤„ç†çŠ¶æ€ä¸‹çš„ç¦ç”¨é€»è¾‘
		 if (state.isProcessing || state.isTxtProcessing) {
			 dom.novelSelector.disabled = true;
			 dom.chapterListEl.querySelectorAll('input').forEach(cb => cb.disabled = true);
		 } else {
			 dom.novelSelector.disabled = false;
			 dom.chapterListEl.querySelectorAll('input').forEach(cb => cb.disabled = false);
		 }
	}
	
	// --- å…¨æ–°çš„éŸ³è‰²åº“ä¸ç®¡ç†å™¨é€»è¾‘æ¨¡å— ---
	let timbreData = { categories: {}, unassigned: [] };

	async function loadTimbres() {
		try {
			timbreData = await fetchFromServer('/api/timbres/data');
            // å…ˆå°†æ‰€æœ‰æœªåˆ†ç±»éŸ³è‰²åŠ å…¥
            state.allTimbres = [...timbreData.unassigned];
            // éå†æ‰€æœ‰åˆ†ç±»ï¼Œå°†å…¶ä¸‹çš„éŸ³è‰²ä¹ŸåŠ å…¥
            for (const categoryName in timbreData.categories) {
                state.allTimbres.push(...timbreData.categories[categoryName]);
            }
			
			const filter = document.getElementById('categoryFilter');
			const currentFilterValue = filter.value;
			filter.innerHTML = `
				<option value="all">-- æ‰€æœ‰åˆ†ç±» --</option>
				<option value="unassigned">-- æœªåˆ†ç±» --</option>
			`;
			const sortedCategories = Object.keys(timbreData.categories).sort();
			sortedCategories.forEach(cat => {
				const option = document.createElement('option');
				option.value = option.textContent = cat;
				filter.appendChild(option);
			});

			if (Array.from(filter.options).some(opt => opt.value === currentFilterValue)) {
				filter.value = currentFilterValue;
			} else {
				filter.value = 'all';
			}
			
			renderTimbreList();
		} catch(e) {
			setStatus(`åŠ è½½éŸ³è‰²å¤±è´¥: ${e.message}`, 'error');
			timbreData = { categories: {}, unassigned: [] };
            state.allTimbres = []; // é”™è¯¯æ—¶ä¹Ÿæ¸…ç©ºï¼Œä¿æŒçŠ¶æ€ä¸€è‡´
            state.timbreDetails = {};
			renderTimbreList();
		}
	}

	function renderTimbreList() {
		dom.timbreListEl.innerHTML = '';
		if (!timbreData) return;

		const filterValue = document.getElementById('categoryFilter').value;
		const { categories, unassigned } = timbreData;
		let timbresToRender = [];

		if (filterValue === 'all') {
			timbresToRender = [...unassigned];
			Object.values(categories).forEach(arr => timbresToRender.push(...arr));
		} else if (filterValue === 'unassigned') {
			timbresToRender = [...unassigned];
		} else if (categories[filterValue]) {
			timbresToRender = [...categories[filterValue]];
		}

		if (timbresToRender.length === 0) {
			dom.timbreListEl.innerHTML = '<p class="placeholder-text">æ­¤åˆ†ç±»/éŸ³è‰²åº“ä¸‹æ²¡æœ‰éŸ³è‰²</p>';
			return;
		}

		timbresToRender.sort().forEach(t => {
			const li = document.createElement('li');
			li.innerHTML = `<span class="label">${t}</span>
						  <div class="timbre-actions">
                            <div class="popover-container roles-popover" style="display: none; position: relative;">
                                <button class="btn-show-roles" title="æŸ¥çœ‹å·²åˆ†é…è§’è‰²">â˜°</button>
                                <div class="popover-content" style="right: 105%; top: 50%; transform: translateY(-50%);">
                                    <strong>å·²åˆ†é…ç»™:</strong>
                                    <ul></ul>
                                </div>
                            </div>
							<button class="btn btn-assign" data-timbre-name="${t}">åˆ†é…</button>
							<button class="audio-player-btn playable" data-timbre-name="${t}" title="è¯•å¬ ${t}">â–¶</button>
						  </div>`;
			dom.timbreListEl.appendChild(li);
		});
		updateRelatedRolesPopovers();
	}
    
	// === 5. EVENT LISTENERS ===	
	
	const dom_timbres_manager = {
		openBtn: document.getElementById('manageTimbresBtn'),
		modal: document.getElementById('timbresManageModal'),
		closeBtn: document.getElementById('closeTimbresManageBtn'),
		categoryList: document.getElementById('manager-category-list'),
		newCatInput: document.getElementById('managerNewCategoryInput'),
		addCatBtn: document.getElementById('managerAddCategoryBtn'),
		timbresTitle: document.getElementById('manager-timbres-title'),
		timbresList: document.getElementById('manager-timbres-list'),
		uploadCategorySelect: document.getElementById('uploadTimbreCategory'),
		categoryFilter: document.getElementById('categoryFilter')
	};
	let managerState = { selectedCategory: 'unassigned' };
		
	// ç­›é€‰ä¸»åˆ—è¡¨
	dom_timbres_manager.categoryFilter.addEventListener('change', renderTimbreList);

	dom_timbres_manager.openBtn.addEventListener('click', async () => {
		dom_timbres_manager.modal.style.display = 'flex';
		managerState.selectedCategory = 'unassigned';
		try {
			timbreData = await fetchFromServer('/api/timbres/data');
			renderTimbresManager();
		} catch(e) { setStatus(`åŠ è½½éŸ³è‰²æ•°æ®å¤±è´¥: ${e.message}`, 'error'); }
	});

	dom_timbres_manager.closeBtn.addEventListener('click', () => {
        stopAllAudio(); // åœ¨å…³é—­æ¨¡æ€æ¡†å‰åœæ­¢æ‰€æœ‰éŸ³é¢‘
		dom_timbres_manager.modal.style.display = 'none';
		loadTimbres();
	});

	dom_timbres_manager.categoryList.addEventListener('click', (e) => {
		const li = e.target.closest('li');
		if (li && li.dataset.categoryName) {
			managerState.selectedCategory = li.dataset.categoryName;
			renderTimbresManager();
		}
	});

	dom_timbres_manager.addCatBtn.addEventListener('click', managerCreateCategory);
	dom_timbres_manager.newCatInput.addEventListener('keypress', (e) => {
		if (e.key === 'Enter') managerCreateCategory();
	});

	dom_timbres_manager.timbresList.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.matches('.btn-move-timbre')) { // ä½¿ç”¨æ›´ç²¾ç¡®çš„é€‰æ‹©å™¨ï¼ŒåªåŒ¹é…â€œç§»åŠ¨åˆ°â€æŒ‰é’®
            const timbreName = target.dataset.timbreName;
            const popover = target.nextElementSibling;
            let menuHtml = '<ul>';
            menuHtml += `<li><button class="category-move-btn" data-timbre="${timbreName}" data-category="">-- æœªåˆ†ç±» --</button></li>`;
            Object.keys(timbreData.categories).sort().forEach(cat => {
                if (cat !== managerState.selectedCategory) {
                    menuHtml += `<li><button class="category-move-btn" data-timbre="${timbreName}" data-category="${cat}">${cat}</button></li>`;
                }
            });
            menuHtml += '</ul>';
            popover.innerHTML = menuHtml;
        }
        else if (target.matches('.category-move-btn')) {
            const timbreName = target.dataset.timbre;
            const categoryName = target.dataset.category;
            try {
                const result = await fetchFromServer('/api/timbres/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timbre_name: timbreName, category_name: categoryName })
                });
                timbreData = result.data;
                renderTimbresManager();
            } catch(e) { alert(`ç§»åŠ¨å¤±è´¥: ${e.message}`); }
        }
        else if (target.matches('.btn-delete-timbre')) {
            const timbreName = target.dataset.timbreName;
            if (!confirm(`æ‚¨ç¡®å®šè¦æ°¸ä¹…åˆ é™¤éŸ³è‰²ã€Œ${timbreName}ã€å—ï¼Ÿ`)) return;
            try {
                await fetchFromServer(`/api/delete_timbre?timbre_name=${encodeURIComponent(timbreName)}`, { method: 'DELETE' });
                // åˆ é™¤åï¼Œéœ€è¦æ›´æ–°æœ¬åœ°çš„ timbreData å¹¶é‡æ–°æ¸²æŸ“
                if (managerState.selectedCategory === 'unassigned') {
                    timbreData.unassigned = timbreData.unassigned.filter(t => t !== timbreName);
                } else {
                    timbreData.categories[managerState.selectedCategory] = timbreData.categories[managerState.selectedCategory].filter(t => t !== timbreName);
                }
                renderTimbresManager();
                setStatus('éŸ³è‰²åˆ é™¤æˆåŠŸï¼', 'success');
            } catch (error) { 
                setStatus(`åˆ é™¤éŸ³è‰²å¤±è´¥: ${error.message}`, 'error'); 
            }
        }
        // *** æ ¸å¿ƒä¿®æ”¹ï¼šä¸ºæ’­æ”¾æŒ‰é’®æ·»åŠ é€»è¾‘ ***
        else if (target.matches('.audio-player-btn')) {
            const timbreName = target.dataset.timbreName;
            if (timbreName) {
                toggleSimpleAudio(target, `/wav/${timbreName}/1.wav`);
            } else {
                setStatus('é”™è¯¯ï¼šæœªèƒ½è·å–éŸ³è‰²åç§°è¿›è¡Œæ’­æ”¾ã€‚', 'error');
            }
        }
    });
	
	dom.uploadTimbreLabelBtn.addEventListener('click', async () => {
		try {
			const data = await fetchFromServer('/api/timbres/data');
			const select = dom_timbres_manager.uploadCategorySelect;
			select.innerHTML = '<option value="">-- ä¸å½’ç±» --</option>';
			Object.keys(data.categories).sort().forEach(cat => {
				const option = document.createElement('option');
				option.value = option.textContent = cat;
				select.appendChild(option);
			});
		} catch (e) { console.error("åŠ è½½åˆ†ç±»å¤±è´¥:", e); }
		dom.timbreFile.click();
	});

	// --- æ¢å¤çš„ã€åªå¤„ç†åˆ†é…å’Œæ’­æ”¾çš„ timbreListEl äº‹ä»¶ç›‘å¬å™¨ ---
	dom.timbreListEl.addEventListener('click', async (e) => {
		const target = e.target;
		if (target.matches('.btn-assign')) {
			if (!state.selectedCharacter) { alert('è¯·å…ˆåœ¨è§’è‰²åˆ—è¡¨ä¸­ç‚¹å‡»é€‰ä¸­ä¸€ä¸ªè§’è‰²ï¼'); return; }
			const timbreName = target.dataset.timbreName;
			state.characterMapping[state.selectedCharacter] = timbreName;
			await loadCharacters();
			if (state.selectedChapterPaths.length === 1 && dom.contentTable.style.display === 'table') {
				renderContentTable();
				await checkAllPlayableFiles();
			}
            updateRelatedRolesPopovers();
			setStatus(`å·²å°†éŸ³è‰² '${timbreName}' åˆ†é…ç»™è§’è‰² '${state.selectedCharacter}'`, 'success');
		}
		else if (target.matches('.audio-player-btn')) { 
			toggleSimpleAudio(target, `/wav/${target.dataset.timbreName}/1.wav`);
		}
	});
	

	// ã€æ ¸å¿ƒè¡¥å……ã€‘æ¸²æŸ“ç®¡ç†å™¨UIçš„å®Œæ•´å‡½æ•°
	function renderTimbresManager() {
		const { categories, unassigned } = timbreData;
		
		// 1. æ¸²æŸ“å·¦ä¾§åˆ†ç±»åˆ—è¡¨
		let catListHtml = `<ul class="info-list">`;
		// â€œæœªåˆ†ç±»â€é¡¹
		catListHtml += `<li class="selectable ${managerState.selectedCategory === 'unassigned' ? 'selected' : ''}" data-category-name="unassigned">
							<span class="label">æœªåˆ†ç±»</span>
							<span class="value">${unassigned.length}</span>
						</li>`;
		// å…¶ä»–åˆ†ç±»é¡¹
		Object.keys(categories).sort().forEach(catName => {
			catListHtml += `<li class="selectable ${managerState.selectedCategory === catName ? 'selected' : ''}" data-category-name="${catName}">
								<span class="label">${catName}</span>
								<span class="value">${categories[catName].length}</span>
							</li>`;
		});
		catListHtml += `</ul>`;
		dom_timbres_manager.categoryList.innerHTML = catListHtml;

		// 2. æ¸²æŸ“å³ä¾§éŸ³è‰²åˆ—è¡¨
		dom_timbres_manager.timbresTitle.textContent = managerState.selectedCategory === 'unassigned' ? 'æœªåˆ†ç±»éŸ³è‰²' : `åˆ†ç±»: ${managerState.selectedCategory}`;
		let timbresToShow = managerState.selectedCategory === 'unassigned' ? unassigned : categories[managerState.selectedCategory];
		
		if (!timbresToShow || timbresToShow.length === 0) {
			dom_timbres_manager.timbresList.innerHTML = '<p class="placeholder-text">æ­¤åˆ†ç±»ä¸‹æ²¡æœ‰éŸ³è‰²</p>';
			return;
		}

		let timbreListHtml = '';
		timbresToShow.forEach(timbreName => {
			timbreListHtml += `<li>
								<span class="label">${timbreName}</span>
								<div class="timbre-actions">
									<div class="popover-container">
										<button class="btn btn-move-timbre" data-timbre-name="${timbreName}">ç§»åŠ¨åˆ°</button>
										<div class="popover-content category-menu"></div>
									</div>
                                    <button class="audio-player-btn playable" data-timbre-name="${timbreName}" title="è¯•å¬ ${timbreName}">â–¶</button>
									<button class="btn btn-danger btn-delete-timbre" data-timbre-name="${timbreName}" title="åˆ é™¤éŸ³è‰²">X</button>
								</div>
							   </li>`;
		});
		dom_timbres_manager.timbresList.innerHTML = timbreListHtml;
        updateRelatedRolesPopovers(); //
	}

	// åˆ›å»ºæ–°åˆ†ç±»
	async function managerCreateCategory() {
		const newName = dom_timbres_manager.newCatInput.value.trim();
		if (!newName) return;
		try {
			const result = await fetchFromServer('/api/timbres/categories', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ category_name: newName })
			});
			timbreData = result.data; // ä½¿ç”¨åç«¯è¿”å›çš„æœ€æ–°æ•°æ®
			managerState.selectedCategory = newName; // é€‰ä¸­æ–°åˆ›å»ºçš„åˆ†ç±»
			renderTimbresManager();
			dom_timbres_manager.newCatInput.value = '';
		} catch (e) { alert(`åˆ›å»ºå¤±è´¥: ${e.message}`); }
	}

    // --- State for the modal ---
    let charManageState = { allChars: [], selectedChars: [] };

    // --- Helper functions for the modal ---
    function renderCharManageList() {
        const listEl = dom.charManageList;
        const searchTerm = dom.charSearchInput.value.toLowerCase();
        listEl.innerHTML = '';
        
        const filteredChars = charManageState.allChars.filter(c => c.toLowerCase().includes(searchTerm));

        filteredChars.forEach(char => {
            const isChecked = charManageState.selectedChars.includes(char);
            const label = document.createElement('label');
            label.className = 'info-list-item'; // Simple styling
            label.style.display = 'flex'; label.style.padding = '0.4rem'; label.style.cursor = 'pointer';
            label.innerHTML = `<input type="checkbox" class="char-manage-cb" value="${char}" ${isChecked ? 'checked' : ''}> ${char}`;
            listEl.appendChild(label);
        });
    }

    function updateMergeControls() {
        const selected = charManageState.selectedChars;
        dom.charsToMerge.innerHTML = selected.map(c => `<span class="badge" style="background: #e8f0fe; padding: 2px 6px; border-radius: 4px; margin: 2px;">${c}</span>`).join(' ');
        
        const selectEl = dom.targetCharSelect;
        selectEl.innerHTML = '';
        if (selected.length > 0) {
            selected.forEach(c => {
                const option = document.createElement('option');
                option.value = option.textContent = c;
                selectEl.appendChild(option);
            });
            selectEl.disabled = false;
        } else {
            selectEl.disabled = true;
        }

        dom.confirmMergeBtn.disabled = selected.length < 2;
    }

    // --- Event Listeners for the modal ---
    dom.manageCharactersBtn.addEventListener('click', async () => {
        if (!state.novelName) return;

        setStatus('æ­£åœ¨è·å–æ‰€æœ‰è§’è‰²åˆ—è¡¨...', 'info');
        dom.charManageModal.style.display = 'flex';
        dom.charManageList.innerHTML = '<p class="placeholder-text">åŠ è½½ä¸­...</p>';
        
        charManageState = { allChars: [], selectedChars: [] }; // Reset state
        updateMergeControls();

        try {
            // *** æ ¸å¿ƒä¿®æ”¹ 1: åœ¨æ‰“å¼€æ—¶ï¼Œå…ˆå¼ºåˆ¶åˆ·æ–°ä¸€æ¬¡å°è¯´æ•°æ® ***
            // è¿™èƒ½ç¡®ä¿ state.allNovelsData åŒ…å«æœ€æ–°çš„ processed å’Œ spliced çŠ¶æ€
            await loadNovels();
            // åœ¨ä¸‹æ‹‰æ¡†ä¸­é‡æ–°é€‰ä¸­å½“å‰å°è¯´ï¼Œä»¥é˜²åˆ—è¡¨é¡ºåºå˜åŒ–
            dom.novelSelector.value = state.novelName;
            
            const novelData = state.allNovelsData[state.novelName];

            if (!novelData || !novelData.chapters) {
                throw new Error("æ— æ³•è·å–å½“å‰å°è¯´çš„ç« èŠ‚æ•°æ®ã€‚");
            }
		
			const selectedChapterFiles = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked'))
				.filter(cb => cb.value.endsWith('.json')) // ç¡®ä¿æ˜¯å·²å¤„ç†çš„ç« èŠ‚
				.map(cb => cb.value.split(/[/\\]/).pop()); // åªå–æ–‡ä»¶åéƒ¨åˆ†

			if (selectedChapterFiles.length === 0) {
				 dom.charManageList.innerHTML = '<p class="placeholder-text">è¯·å…ˆåœ¨å·¦ä¾§è‡³å°‘é€‰æ‹©ä¸€ä¸ªã€å·²å¤„ç†ã€‘çš„ç« èŠ‚ã€‚</p>';
				 setStatus('è¯·å…ˆé€‰æ‹©å·²å¤„ç†çš„ç« èŠ‚ä»¥ç®¡ç†è§’è‰²ã€‚', 'warning');
				 return;
			}
            
			console.log(`[Char Manage] Requesting characters from ${selectedChapterFiles.length} selected files.`);

            const payload = { novel_name: state.novelName, chapter_files: selectedChapterFiles  };
            const data = await fetchFromServer('/api/get_characters_in_chapters', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            
            if (!data.characters || data.characters.length === 0) {
                dom.charManageList.innerHTML = '<p class="placeholder-text">åœ¨å·²å¤„ç†çš„ç« èŠ‚ä¸­æœªå‘ç°ä»»ä½•è§’è‰²åã€‚</p>';
            } else {
                charManageState.allChars = (data.characters || []).filter(c => c !== 'æ—ç™½').sort();
                renderCharManageList();
            }
            
            setStatus('è§’è‰²åˆ—è¡¨åŠ è½½å®Œæ¯•ã€‚', 'success');

        } catch (error) {
            dom.charManageList.innerHTML = `<p class="placeholder-text" style="color:var(--danger-color);">åŠ è½½è§’è‰²å¤±è´¥: ${error.message}</p>`;
            setStatus(`åŠ è½½è§’è‰²å¤±è´¥: ${error.message}`, 'error');
        }
    });
    
    dom.charSearchInput.addEventListener('input', renderCharManageList);

    dom.charManageList.addEventListener('change', e => {
        if (e.target.matches('.char-manage-cb')) {
            const charName = e.target.value;
            if (e.target.checked) {
                if (!charManageState.selectedChars.includes(charName)) {
                    charManageState.selectedChars.push(charName);
                }
            } else {
                charManageState.selectedChars = charManageState.selectedChars.filter(c => c !== charName);
            }
            updateMergeControls();
        }
    });

    dom.confirmMergeBtn.addEventListener('click', async () => {
        const targetName = dom.targetCharSelect.value;
        const sourceNames = charManageState.selectedChars.filter(c => c !== targetName);

        if (!targetName || sourceNames.length === 0) {
            alert('è¯·ç¡®ä¿å·²é€‰æ‹©ä¸»è§’è‰²ï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªå…¶ä»–è§’è‰²è¦è¢«åˆå¹¶ã€‚');
            return;
        }
        
        if (!confirm(`ç¡®å®šè¦å°† ${sourceNames.join(', ')} åˆå¹¶åˆ° ${targetName} å—ï¼Ÿ\næ­¤æ“ä½œå°†ä¿®æ”¹æ‰€æœ‰ç« èŠ‚æ–‡ä»¶ï¼Œä¸”ä¸å¯æ’¤é”€ã€‚`)) {
            return;
        }

        setStatus('æ­£åœ¨æ‰§è¡Œåˆå¹¶æ“ä½œ...', 'info');
        dom.confirmMergeBtn.disabled = true;
        dom.confirmMergeBtn.textContent = 'åˆå¹¶ä¸­...';

        try {
			const selectedChapterFiles = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked'))
				.filter(cb => cb.value.endsWith('.json'))
				.map(cb => cb.value.split(/[/\\]/).pop());

			if (selectedChapterFiles.length === 0) {
				alert('æ‰§è¡Œåˆå¹¶å‰ï¼Œå¿…é¡»åœ¨å·¦ä¾§åˆ—è¡¨ä¸­è‡³å°‘é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚');
				return;
			}
			
            const payload = {
                novel_name: state.novelName,
                target_name: targetName,
                source_names: sourceNames,
				chapter_files: selectedChapterFiles
            };
            const result = await fetchFromServer('/api/merge_characters', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            setStatus(result.message, 'success');
            dom.charManageModal.style.display = 'none';

            // å…³é”®ï¼šåˆ·æ–°æ‰€æœ‰ç›¸å…³UI
            await loadNovels();
            renderChapterList();
            await loadAndApplyConfig(); // åŠ è½½æ›´æ–°åçš„éŸ³è‰²é…ç½®
            await loadCharacters();     // åˆ·æ–°è§’è‰²åˆ—è¡¨
            // å¦‚æœç¼–è¾‘å™¨å¼€ç€ï¼Œä¹Ÿåˆ·æ–°å®ƒ
            if (state.selectedChapterPaths.length === 1 && dom.editorView.style.display === 'block') {
                await loadSingleChapterForEditing(state.selectedChapterPaths[0]);
            }

        } catch (error) {
            setStatus(`åˆå¹¶å¤±è´¥: ${error.message}`, 'error');
            alert(`åˆå¹¶å¤±è´¥: ${error.message}`);
        } finally {
            dom.confirmMergeBtn.disabled = false;
            dom.confirmMergeBtn.textContent = 'ç¡®è®¤åˆå¹¶';
        }
    });

    dom.closeCharManageBtn.addEventListener('click', () => {
        dom.charManageModal.style.display = 'none';
    });
	
    // *** æ ¸å¿ƒä¿®æ”¹ 5: æ·»åŠ æ‰“å¼€å’Œå¤„ç†â€œå¤šäººåŒå£°â€æ¨¡æ€æ¡†çš„å‡½æ•° ***
    function openChoralModal(rowIndex) {
        dom.choralModal.style.display = 'flex';
        const listEl = dom.choralTimbreList;
        listEl.innerHTML = ''; // æ¸…ç©ºæ—§åˆ—è¡¨
		
		const speaker = state.novelData[rowIndex] ? state.novelData[rowIndex].speaker : null;
		const timbre = speaker ? state.characterMapping[speaker] : null;

		// å¢åŠ å¥å£®æ€§æ£€æŸ¥ï¼Œå¦‚æœæ— æ³•è·å–è§’è‰²æˆ–éŸ³è‰²ä¿¡æ¯ï¼Œåˆ™ä¸ç»§ç»­æ‰§è¡Œ
		if (!speaker || !timbre) {
			alert(`æ— æ³•ä¸ºç¬¬ ${rowIndex + 1} è¡Œæ‰§è¡Œæ­¤æ“ä½œï¼Œå› ä¸ºç¼ºå°‘è§’è‰²æˆ–éŸ³è‰²é…ç½®ã€‚`);
			dom.choralModal.style.display = 'none'; // å…³é—­æ¨¡æ€æ¡†
			return;
		}

        // ç”¨ state.allTimbres å¡«å……åˆ—è¡¨
        state.allTimbres.forEach(timbre => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.padding = '0.4rem';
            label.style.cursor = 'pointer';
            label.innerHTML = `<input type="checkbox" class="choral-timbre-cb" value="${timbre}"> ${timbre}`;
            listEl.appendChild(label);
        });

        // ä¸ºâ€œç¡®è®¤â€æŒ‰é’®ç»‘å®šä¸€æ¬¡æ€§äº‹ä»¶ç›‘å¬å™¨
        const handleConfirm = async () => {
            const selectedTimbres = Array.from(listEl.querySelectorAll('.choral-timbre-cb:checked')).map(cb => cb.value);
            
            if (selectedTimbres.length < 2) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸¤ä¸ªéŸ³è‰²ä»¥äº§ç”Ÿå¤šäººåŒå£°æ•ˆæœã€‚');
                return;
            }

            // å…³é—­æ¨¡æ€æ¡†å¹¶å¼€å§‹å¤„ç†
            dom.choralModal.style.display = 'none';
            setStatus(`æ­£åœ¨ç”Ÿæˆ ${selectedTimbres.length} äººåŒå£°æ•ˆæœ...`, 'info');

            const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
            const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
			const payload = {
				novel_name: state.novelName,
				chapter_name: currentChapterName,
				row_index: rowIndex,
				tts_text: state.novelData[rowIndex].content,
				selected_timbres: selectedTimbres,
				original_speaker: speaker,   // æ–°å¢ï¼šåŸå§‹è§’è‰²å
				original_timbre: timbre,      // æ–°å¢ï¼šåŸå§‹éŸ³è‰²å
				tts_model: dom.contentTableBody.querySelector(`#content-row-${rowIndex} .tts-model-select`).value
			};

            try {
                const result = await fetchFromServer('/api/generate_choral_effect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                // æ›´æ–°å‰ç«¯çŠ¶æ€ï¼Œä»¥ä¾¿èƒ½æ’­æ”¾è¿™ä¸ªæ–°ç”Ÿæˆçš„æ–‡ä»¶
                state.generatedFiles[rowIndex] = result.file_name;
                const row = dom.contentTableBody.children[rowIndex];
                if (row) {
                    row.querySelector('.btn-play').disabled = false;
                    row.querySelector('.btn-effects').disabled = false;
                }
                setStatus(result.message, 'success');
                // è‡ªåŠ¨æ’­æ”¾
                playAudio(`/output/${state.novelName}/wavs/${currentChapterName}/${result.file_name}`);

            } catch (error) {
                setStatus(`å¤šäººåŒå£°æ•ˆæœç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }

            // è§£ç»‘äº‹ä»¶ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            dom.confirmChoralBtn.removeEventListener('click', handleConfirm);
			dom.cancelChoralBtn.removeEventListener('click', handleCancel); // ä¹Ÿè¦è§£ç»‘å–æ¶ˆæŒ‰é’®
        };
        
        dom.confirmChoralBtn.addEventListener('click', handleConfirm);

        // ä¸ºâ€œå–æ¶ˆâ€æŒ‰é’®ä¹Ÿç»‘å®šä¸€æ¬¡æ€§äº‹ä»¶
        const handleCancel = () => {
            dom.choralModal.style.display = 'none';
            // è§£ç»‘ä¸¤ä¸ªäº‹ä»¶
            dom.confirmChoralBtn.removeEventListener('click', handleConfirm);
            dom.cancelChoralBtn.removeEventListener('click', handleCancel);
        };
        dom.cancelChoralBtn.addEventListener('click', handleCancel);
    }
	
    // *** æ ¸å¿ƒä¿®æ”¹ 2: æ·»åŠ æ–°çš„æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ***
    async function showCharacterDialogues(characterName) {
        // è·å–å½“å‰é€‰ä¸­çš„æ‰€æœ‰ç« èŠ‚æ ‡é¢˜
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
        const chapterTitles = Array.from(selectedCheckboxes).map(cb => cb.dataset.title);
        
        // æ˜¾ç¤ºæ¨¡æ€æ¡†å¹¶è®¾ç½®åˆå§‹çŠ¶æ€
        dom.dialogueModal.style.display = 'flex';
        dom.dialogueModalTitle.textContent = `è§’è‰²ã€Œ${characterName}ã€åœ¨é€‰ä¸­ç« èŠ‚ä¸­çš„ç›¸å…³å¥å­`;
        dom.dialogueModalBody.innerHTML = '<p class="placeholder-text">æ­£åœ¨æœç´¢åŸæ–‡...</p>';

        if (chapterTitles.length === 0) {
            dom.dialogueModalBody.innerHTML = '<p class="placeholder-text">è¯·å…ˆåœ¨ç¬¬ä¸€åˆ—ä¸­è‡³å°‘é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚</p>';
            return;
        }

        try {
            // æ„é€ è¯·æ±‚ä½“
            const payload = {
                novel_name: state.novelName,
                character_name: characterName,
                chapter_titles: chapterTitles
            };

            // è°ƒç”¨æ–°çš„åç«¯API
            const result = await fetchFromServer('/api/search_character_sentences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const sentences = result.sentences || [];

            // æ¸²æŸ“æœ€ç»ˆç»“æœ
            if (sentences.length === 0) {
                dom.dialogueModalBody.innerHTML = `<p class="placeholder-text">åœ¨é€‰ä¸­çš„ ${chapterTitles.length} ä¸ªç« èŠ‚ä¸­æœªæ‰¾åˆ°åŒ…å«ã€Œ${characterName}ã€çš„å¥å­ã€‚</p>`;
            } else {
                let html = '<ul>';
                sentences.forEach(sentence => {
                    // é«˜äº®è§’è‰²å
                    const highlightedContent = sentence.content.replace(
                        new RegExp(characterName, 'g'),
                        `<strong style="color: var(--primary-color);">${characterName}</strong>`
                    );
                    html += `<li>
                               <span class="dialogue-source">æ¥è‡ªç« èŠ‚: ${sentence.source}</span>
                               ${highlightedContent}
                             </li>`;
                });
                html += '</ul>';

                if (sentences.length >= 20) {
                    html += `<p style="text-align: center; margin-top: 1rem; color: var(--text-color-secondary);">ï¼ˆä»…æ˜¾ç¤ºå‰ ${sentences.length} æ¡ç›¸å…³å¥å­ï¼‰</p>`;
                }
                dom.dialogueModalBody.innerHTML = html;
            }

        } catch (error) {
            dom.dialogueModalBody.innerHTML = `<p class="placeholder-text" style="color: var(--danger-color);">æœç´¢æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}</p>`;
        }
    }
	
	async function handleNovelSelection(isUploadTriggered = false) { // å¢åŠ ä¸€ä¸ªé»˜è®¤å‚æ•°
        // **ã€æ ¸å¿ƒä¿®å¤ã€‘**
        // å¦‚æœæ˜¯ç”±ä¸Šä¼ è§¦å‘çš„ï¼Œæˆ‘ä»¬è·³è¿‡ change äº‹ä»¶çš„æ‹¦æˆªé€»è¾‘
        if (!isUploadTriggered && state.isProgrammaticChange) {
            state.isProgrammaticChange = false;
            return;
        }
        // å¦‚æœæ˜¯æ­£å¸¸çš„ç”¨æˆ·ç‚¹å‡»ï¼Œæˆ–è€…ä¸Šä¼ åæ‰‹åŠ¨è°ƒç”¨ï¼Œåˆ™é‡ç½®æ——å¸œ
        state.isProgrammaticChange = false;

		state.novelName = dom.novelSelector.value;
        dom.deleteNovelBtn.disabled = !state.novelName;
        dom.manageCharactersBtn.disabled = !state.novelName;
        dom.manageReplaceDictBtn.disabled = !state.novelName; 
		dom.novelTxtFile.value = '';
		
		dom.chapterListEl.innerHTML = '<p class="placeholder-text">è¯·å…ˆé€‰æ‹©ä¸€æœ¬å°è¯´</p>';
		dom.characterListEl.innerHTML = '<p class="placeholder-text">é€‰æ‹©ç« èŠ‚åæ˜¾ç¤º</p>';
		dom.saveConfigBtn.disabled = true;

		if (state.novelName) {
			await renderChapterList(); 
			await loadAndApplyConfig(); 
		} else {
			await renderChapterList(); 
		}
		
		handleChapterSelectionChange();
	}
    
	// --- New Global Settings Logic ---

	function renderGlobalSettingsModal() {
		const config = state.globalConfig;
		if (!config || !config.general || !config.models || !config.audio_export) {
			console.error("Incomplete global config received from backend.");
			return;
		}

		// --- Tab: General Settings ---
		const defaultModelSelect = dom.settingsDefaultModel;
		defaultModelSelect.innerHTML = '';
		Object.keys(config.models).forEach(modelId => {
			const option = document.createElement('option');
			option.value = modelId;
			option.textContent = config.models[modelId].display_name || modelId;
			defaultModelSelect.appendChild(option);
		});
		defaultModelSelect.value = config.general.default_model;
		
		
		const defaultTtsModelSelect = dom.settingsDefaultTtsModel;
		defaultTtsModelSelect.innerHTML = '';
		const ttsModels = config.tts_models || {};
		for (const modelId in ttsModels) {
			const option = document.createElement('option');
			option.value = modelId;
			option.textContent = ttsModels[modelId].display_name || modelId;
			defaultTtsModelSelect.appendChild(option);
		}
		defaultTtsModelSelect.value = config.general.default_tts_model;

		const proxy = config.general.proxy;
		dom.settingsProxyEnabled.checked = proxy.enabled;
		dom.proxyDetailsGroup.style.display = proxy.enabled ? 'block' : 'none';
		dom.settingsProxyProtocol.value = proxy.protocol;
		dom.settingsProxyAddress.value = proxy.address;
		dom.settingsProxyPort.value = proxy.port;

		// --- Tab: Model Settings ---
		const llmForm = dom.llmSettingsForm;
		llmForm.innerHTML = '';
		for (const modelId in config.models) {
			const model = config.models[modelId];
			const fieldset = document.createElement('fieldset');
			fieldset.style = "border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;";
			fieldset.innerHTML = `
				<legend style="font-weight: 500;">${model.display_name || modelId}</legend>
				<div class="input-group">
					<label for="modelname-${modelId}">Model Name</label>
					<input type="text" id="modelname-${modelId}" data-model-id="${modelId}" data-key="model_name" value="${model.model_name || ''}" placeholder="e.g., gemini-2.5-flash">
				</div>
				<div class="input-group">
					<label for="apikey-${modelId}">API Key</label>
					<input type="password" id="apikey-${modelId}" data-model-id="${modelId}" data-key="api_key" value="${model.api_key || ''}" placeholder="è¯·è¾“å…¥API Key">
				</div>
				<div class="input-group">
					<label for="maxchars-${modelId}">æœ€å¤§å­—ç¬¦æ•° (ç”¨äºåˆ†å—)</label>
					<input type="number" id="maxchars-${modelId}" data-model-id="${modelId}" data-key="max_chars" value="${model.max_chars || 1000}">
				</div>
				<div class="config-group inline-group">
					<label for="useproxy-${modelId}">ä½¿ç”¨ä»£ç†æœåŠ¡å™¨</label>
					<input type="checkbox" id="useproxy-${modelId}" data-model-id="${modelId}" data-key="use_proxy" ${model.use_proxy ? 'checked' : ''} style="width: auto; height: auto;">
				</div>
			`;
			llmForm.appendChild(fieldset);
		}

		// --- æ¸²æŸ“ Tab: TTS æ¨¡å‹é…ç½® ---
        const ttsForm = dom.ttsSettingsForm;
        ttsForm.innerHTML = '';
        // ç›´æ¥ä½¿ç”¨ config.tts_modelsï¼Œé¿å…å˜é‡é‡å
        for (const modelId in config.tts_models) { 
            const model = config.tts_models[modelId];
            const fieldset = document.createElement('fieldset');
            fieldset.style = "border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;";
            fieldset.innerHTML = `
                <legend style="font-weight: 500;">${modelId}</legend>
                <div class="input-group">
                    <label for="tts-displayname-${modelId}">æ˜¾ç¤ºåç§°</label>
                    <input type="text" id="tts-displayname-${modelId}" data-model-id="${modelId}" data-key="display_name" value="${model.display_name || ''}">
                </div>
                <div class="input-group">
                    <label for="tts-endpoint-${modelId}">æœåŠ¡åœ°å€ (Endpoint)</label>
                    <input type="text" id="tts-endpoint-${modelId}" data-model-id="${modelId}" data-key="endpoint" value="${model.endpoint || ''}" placeholder="http://127.0.0.1:5010/api/tts">
                </div>
            `;
            ttsForm.appendChild(fieldset);
        }
		
		// --- Tab: Audio Export ---
		dom.exportFormat.value = config.audio_export.format;
		updateQualityOptions(); // This helper function is still useful
		dom.exportQuality.value = config.audio_export.quality;
	}

	async function saveAllSettings() {
		const newConfig = JSON.parse(JSON.stringify(state.globalConfig));

		// General settings
		newConfig.general.default_model = dom.settingsDefaultModel.value;
		newConfig.general.default_tts_model = dom.settingsDefaultTtsModel.value;
		newConfig.general.proxy.enabled = dom.settingsProxyEnabled.checked;
		newConfig.general.proxy.protocol = dom.settingsProxyProtocol.value;
		newConfig.general.proxy.address = dom.settingsProxyAddress.value;
		newConfig.general.proxy.port = dom.settingsProxyPort.value;

		// Model settings
		dom.llmSettingsForm.querySelectorAll('input').forEach(input => {
			const modelId = input.dataset.modelId;
			const key = input.dataset.key;
			if (!modelId || !key) return;

			let value;
			if (input.type === 'checkbox') {
				value = input.checked;
			} else if (input.type === 'number') {
				value = parseInt(input.value, 10) || 0;
			} else {
				value = input.value;
			}
			newConfig.models[modelId][key] = value;
		});
		
		// TTS Model settings
		if (!newConfig.tts_models) newConfig.tts_models = {};
		dom.ttsSettingsForm.querySelectorAll('input').forEach(input => {
			const modelId = input.dataset.modelId;
			const key = input.dataset.key;
			if (!modelId || !key) return;

			// ç¡®ä¿ modelId å­˜åœ¨äºå¯¹è±¡ä¸­
			if (!newConfig.tts_models[modelId]) newConfig.tts_models[modelId] = {};
			
			newConfig.tts_models[modelId][key] = input.value;
		});

		// Audio export settings
		newConfig.audio_export.format = dom.exportFormat.value;
		newConfig.audio_export.quality = dom.exportQuality.value;

		try {
			setStatus('æ­£åœ¨ä¿å­˜æ‰€æœ‰è®¾ç½®...', 'info');
			const result = await fetchFromServer('/api/update_llm_config', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ config: newConfig })
			});
			state.globalConfig = newConfig;
			setStatus(result.message, 'success');
			return true;
		} catch (error) {
			setStatus(`ä¿å­˜è®¾ç½®å¤±è´¥: ${error.message}`, 'error');
			return false;
		}
	}

	dom.settingsBtn.addEventListener('click', () => {
		renderGlobalSettingsModal();
		dom.globalSettingsModal.style.display = 'flex';
	});

	// æ–°å¢è¿™ä¸ªäº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºæ ¹æ®â€œå¯ç”¨ä»£ç†â€å¤é€‰æ¡†æ˜¾ç¤º/éšè—è¯¦ç»†ä¿¡æ¯
	dom.settingsProxyEnabled.addEventListener('change', (e) => {
		dom.proxyDetailsGroup.style.display = e.target.checked ? 'block' : 'none';
	});

	dom.globalSettingsCloseBtn.addEventListener('click', () => {
		dom.globalSettingsModal.style.display = 'none';
	});

	dom.globalSettingsSaveBtn.addEventListener('click', async () => {
        const success = await saveAllSettings();
        if (success) {
            dom.globalSettingsModal.style.display = 'none';
            // Also update the main LLM selector to reflect the new default
            if (state.globalConfig.general) { // Add safety check
                
                dom.llmModelSelector.value = state.globalConfig.general.default_model;
                // åŒæ—¶ï¼Œä¹Ÿåº”è¯¥æ›´æ–° state.selectedLLM çš„å€¼ï¼Œä»¥ä¿æŒçŠ¶æ€ä¸€è‡´
                state.selectedLLM = state.globalConfig.general.default_model;
            }
			if (dom.contentTable.style.display === 'table') {
				renderContentTable();
				checkAllPlayableFiles();
			}
			
			const elevenlabsConfig = state.globalConfig.elevenlabs; // elevenlabs æ˜¯é¡¶çº§é”®
			const hasElevenlabsKey = elevenlabsConfig && elevenlabsConfig.api_key && elevenlabsConfig.api_key.trim() !== '';

            if (hasElevenlabsKey) {
                dom.transcribeBtn.style.display = 'inline-flex'; // å¦‚æœæœ‰ Keyï¼Œåˆ™æ˜¾ç¤ºæŒ‰é’®
                dom.transcribeBtn.title = ''; 
                // æ­¤æ—¶ï¼ŒtranscribeBtn åº”è¯¥å˜ä¸ºå¯ç”¨
                dom.transcribeBtn.disabled = false;
            } else {
                dom.transcribeBtn.style.display = 'none'; // æ²¡æœ‰ Keyï¼Œåˆ™éšè—æŒ‰é’®
            }
        }
    });
	
	dom.contentTableBody.addEventListener('change', (e) => {
		const row = e.target.closest('tr');
		if (!row) return;
		const rowIndex = parseInt(row.id.replace('content-row-', ''), 10);
		if (isNaN(rowIndex)) return;
		const item = state.novelData[rowIndex];
		if (!item) return;

		let changed = false;

		// 1. TTSæ¨¡å‹é€‰æ‹©å˜åŒ– (é€»è¾‘ä¸å˜)
		if (e.target.matches('.tts-model-select')) {
			const selectedTtsModel = e.target.value;
			const isCosyVoice = selectedTtsModel.includes('cosyvoice');
			const modeSelect = row.querySelector('.mode-select');
			if (modeSelect) {
				modeSelect.disabled = !isCosyVoice;
				if (!isCosyVoice) {
					const instructInput = row.querySelector('.instruct-input');
					if (instructInput) instructInput.style.display = 'none';
					modeSelect.value = 'zero_shot';
					if (item.inference_mode !== 'zero_shot') {
						item.inference_mode = 'zero_shot';
						changed = true;
					}
				}
			}
		}

		// 2. æ¨ç†æ¨¡å¼ (mode-select) å˜åŒ–
		if (e.target.matches('.mode-select')) {
			const instructInput = row.querySelector('.instruct-input');
			if (instructInput) {
				const newMode = e.target.value;
				instructInput.style.display = !e.target.disabled && newMode === 'instruct' ? 'block' : 'none';
				// æ ¸å¿ƒä¿®å¤ï¼šå°†ç”¨æˆ·çš„é€‰æ‹©ä¿å­˜åˆ° state.novelData
				if (item.inference_mode !== newMode) {
					item.inference_mode = newMode;
					changed = true;
				}
			}
		}

		// 3. ä¸´æ—¶éŸ³è‰² (timbre-override-select) å˜åŒ–
		if (e.target.matches('.timbre-override-select')) {
			const newTimbre = e.target.value;
			item.timbre_override = newTimbre;
			setStatus(`ç¬¬ ${rowIndex + 1} è¡Œçš„ä¸´æ—¶éŸ³è‰²å·²è®¾ç½®ä¸º: ${newTimbre}`, 'info');
			const generateBtn = row.querySelector('.btn-generate');
			if (generateBtn) generateBtn.disabled = !newTimbre;
			changed = true;
		}
		
		// å¦‚æœæœ‰ä»»ä½•å˜åŒ–ï¼Œåˆ™æ¿€æ´»ä¿å­˜æŒ‰é’®
		if (changed) {
			markChapterAsDirty();
		}
	});

	// åœ¨ä¸Šé¢é‚£ä¸ªå‡½æ•°çš„æ­£ä¸‹æ–¹ï¼Œã€æ·»åŠ ã€‘è¿™ä¸ªæ–°çš„ input äº‹ä»¶ç›‘å¬å™¨
	dom.contentTableBody.addEventListener('input', (e) => {
		if (e.target.matches('.instruct-input')) {
			const row = e.target.closest('tr');
			if (!row) return;
			const rowIndex = parseInt(row.id.replace('content-row-', ''), 10);
			if (isNaN(rowIndex)) return;
			const item = state.novelData[rowIndex];
			if (!item) return;
			
			// æ ¸å¿ƒä¿®å¤ï¼šå°†ç”¨æˆ·è¾“å…¥çš„æŒ‡ä»¤æ–‡æœ¬å®æ—¶ä¿å­˜åˆ° state.novelData
			item.instruct_text = e.target.value;
			markChapterAsDirty();
		}
	});
    // *** æ ¸å¿ƒä¿®æ”¹ 6: æ·»åŠ æ ‡ç­¾é¡µåˆ‡æ¢é€»è¾‘ ***
    const tabsContainer = document.querySelector('.settings-tabs');
    const contentPanels = document.querySelectorAll('.tab-content');
    
    tabsContainer.addEventListener('click', (e) => {
        if (e.target.matches('.tab-link')) {
            const tabId = e.target.dataset.tab;

            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„ active ç±»
            tabsContainer.querySelectorAll('.tab-link').forEach(tab => tab.classList.remove('active'));
            // éšè—æ‰€æœ‰å†…å®¹é¢æ¿
            contentPanels.forEach(panel => panel.classList.remove('active'));

            // ä¸ºè¢«ç‚¹å‡»çš„æ ‡ç­¾å’Œå¯¹åº”çš„å†…å®¹é¢æ¿æ·»åŠ  active ç±»
            e.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
    });
		
    // 1. ç‚¹å‡»ä¸»ç•Œé¢ä¸Šçš„åˆ é™¤å›¾æ ‡æŒ‰é’®
    dom.deleteNovelBtn.addEventListener('click', () => {
        const novelName = state.novelName;
        if (!novelName) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„å°è¯´é¡¹ç›®ã€‚');
            return;
        }

        // æ‰“å¼€ç¡®è®¤æ¨¡æ€æ¡†
        dom.novelToDeleteName.textContent = `ã€Œ${novelName}ã€`;
        dom.deleteConfirmInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
        dom.confirmDeleteBtn.disabled = true; // åˆå§‹ç¦ç”¨ç¡®è®¤æŒ‰é’®
        dom.deleteNovelModal.style.display = 'flex';
        dom.deleteConfirmInput.focus();
    });

    // 2. åœ¨æ¨¡æ€æ¡†çš„è¾“å…¥æ¡†ä¸­è¾“å…¥æ—¶ï¼Œè¿›è¡ŒéªŒè¯
    dom.deleteConfirmInput.addEventListener('input', () => {
        // åªæœ‰å½“ç”¨æˆ·è¾“å…¥çš„å†…å®¹å®Œå…¨ç­‰äº "åˆ é™¤" æ—¶ï¼Œæ‰æ¿€æ´»ç¡®è®¤æŒ‰é’®
        if (dom.deleteConfirmInput.value.trim() === 'åˆ é™¤') {
            dom.confirmDeleteBtn.disabled = false;
        } else {
            dom.confirmDeleteBtn.disabled = true;
        }
    });

    // 3. ç‚¹å‡»æ¨¡æ€æ¡†ä¸­çš„â€œå–æ¶ˆâ€æŒ‰é’®
    dom.cancelDeleteBtn.addEventListener('click', () => {
        dom.deleteNovelModal.style.display = 'none';
    });
    // ç‚¹å‡»èƒŒæ™¯å…³é—­
    dom.deleteNovelModal.addEventListener('click', (e) => {
        if (e.target === dom.deleteNovelModal) {
            dom.deleteNovelModal.style.display = 'none';
        }
    });

    // 4. ç‚¹å‡»æœ€ç»ˆçš„â€œç¡®è®¤åˆ é™¤â€æŒ‰é’®
    dom.confirmDeleteBtn.addEventListener('click', async () => {
        const novelName = state.novelName;
        if (!novelName) return;

        // è¿›å…¥å¤„ç†ä¸­çŠ¶æ€
        dom.confirmDeleteBtn.disabled = true;
        dom.confirmDeleteBtn.textContent = 'åˆ é™¤ä¸­...';
        setStatus(`æ­£åœ¨æ°¸ä¹…åˆ é™¤å°è¯´é¡¹ç›®: ${novelName}...`, 'info');

        try {
            const result = await fetchFromServer(`/api/delete_novel?novel_name=${encodeURIComponent(novelName)}`, {
                method: 'DELETE',
            });

            setStatus(result.message, 'success');
            dom.deleteNovelModal.style.display = 'none';

            // å…³é”®ï¼šåˆ·æ–°å°è¯´åˆ—è¡¨
            await loadNovels();
            // loadNovels åä¼šè‡ªåŠ¨å¡«å……ä¸‹æ‹‰æ¡†ï¼Œä½†æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡é€‰æ‹©é€»è¾‘æ¥æ¸…ç©ºå³ä¾§é¢æ¿
            handleNovelSelection();

        } catch (error) {
            setStatus(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
            alert(`åˆ é™¤å¤±è´¥: ${error.message}`); // åŒæ—¶ç”¨alertç»™å‡ºå¼ºæç¤º
        } finally {
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            dom.confirmDeleteBtn.textContent = 'ç¡®è®¤åˆ é™¤';
            // æ­¤æ—¶ç¡®è®¤æŒ‰é’®åº”è¯¥ä¿æŒç¦ç”¨ï¼Œå› ä¸ºè¾“å…¥æ¡†æ˜¯ç©ºçš„
            dom.confirmDeleteBtn.disabled = true; 
        }
    });
	
    dom.exportFormat.addEventListener('change', updateQualityOptions);
    dom.novelSelector.addEventListener('change', () => {
        handleNovelSelection(); // ç›´æ¥è°ƒç”¨ï¼Œä¸å†éœ€è¦å…¶ä»–é€»è¾‘
    });
    dom.uploadTxtLabelBtn.addEventListener('click', () => {
        dom.novelTxtFile.click(); // æ¨¡æ‹Ÿç‚¹å‡»éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†
    });
    dom.novelTxtFile.addEventListener('change', e => { if (e.target.files[0]) handleTxtFileUpload(e.target.files[0]); });
    dom.llmModelSelector.addEventListener('change', () => {
        state.selectedLLM = dom.llmModelSelector.value;
        console.log(`LLM for processing changed to: ${state.selectedLLM}`);
    });
    
	// click äº‹ä»¶ç°åœ¨åªç”¨äº Shift å¤šé€‰
    dom.chapterListEl.addEventListener('click', e => {
        const checkbox = e.target.closest('input.chapter-checkbox');
        if (!checkbox) return; // å¦‚æœæ²¡ç‚¹åˆ°å¤é€‰æ¡†åŒºåŸŸï¼Œåˆ™å¿½ç•¥

        const visibleCheckboxes = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox'));
        const currentIndex = visibleCheckboxes.indexOf(checkbox);

        // Shift å¤šé€‰é€»è¾‘
        if (e.shiftKey && state.lastCheckedIndex > -1 && state.lastCheckedIndex !== currentIndex) {
            
            // ã€æ ¸å¿ƒä¿®å¤ã€‘æˆ‘ä»¬ä¸å†ä½¿ç”¨ preventDefault()ã€‚
            // è®©æµè§ˆå™¨å…ˆå®Œæˆå®ƒè‡ªå·±çš„ç‚¹å‡»è¡Œä¸ºã€‚

            // a. ç¡®å®šèŒƒå›´
            const start = Math.min(currentIndex, state.lastCheckedIndex);
            const end = Math.max(currentIndex, state.lastCheckedIndex);
            
            // b. ç¡®å®šç›®æ ‡çŠ¶æ€ï¼Œæ°¸è¿œä»¥ç¬¬ä¸€æ¬¡ç‚¹å‡»çš„â€œé”šç‚¹â€å…ƒç´ ä¸ºå‡†ã€‚
            const anchorCheckbox = visibleCheckboxes[state.lastCheckedIndex];
            const targetState = anchorCheckbox.checked;

            // c. æ‰¹é‡ä¿®æ­£çŠ¶æ€
            //    è¿™ä¸ªå¾ªç¯ä¼šæŠŠä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æ‰€æœ‰å…ƒç´ ï¼ˆåŒ…æ‹¬ç»ˆç‚¹æœ¬èº«ï¼‰çš„çŠ¶æ€
            //    éƒ½å¼ºåˆ¶è®¾ç½®æˆå’Œé”šç‚¹å…ƒç´ ä¸€æ ·ã€‚
            for (let i = start; i <= end; i++) {
                visibleCheckboxes[i].checked = targetState;
            }
        }

        // æ›´æ–° lastCheckedIndexï¼Œä¸ºä¸‹ä¸€æ¬¡ Shift ç‚¹å‡»åšå‡†å¤‡
        state.lastCheckedIndex = currentIndex;
        
        // åœ¨æ‰€æœ‰æ“ä½œå®Œæˆåï¼Œè°ƒç”¨æ›´æ–°å‡½æ•°
        setTimeout(() => {
            updateGlobalButtons();
            handleChapterSelectionChange(); // <--- ç¡®ä¿è¿™ä¸€è¡Œå­˜åœ¨ï¼
        }, 0);
    });


    dom.selectAllChaptersBtn.addEventListener('click', () => {
        dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => cb.checked = true);
        updateGlobalButtons();
		handleChapterSelectionChange();
    });
    dom.selectNoneChaptersBtn.addEventListener('click', () => {
        dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => cb.checked = false);
        updateGlobalButtons();
		handleChapterSelectionChange();
    });

    dom.processTxtBtn.addEventListener('click', processTxtChapters);
    dom.processAllBtn.addEventListener('click', processAllAndSplice);
    dom.saveConfigBtn.addEventListener('click', saveConfig);

    // *** æ ¸å¿ƒä¿®æ”¹ 4: ä¸ºæ‰¹é‡ä¸‹è½½æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ ***
    dom.downloadSpliceBtn.addEventListener('click', async () => {
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
        const filePathsToDownload = [];
        
        if (state.novelName && state.allNovelsData[state.novelName]) {
            const novelChapters = state.allNovelsData[state.novelName].chapters;
            for (const checkbox of selectedCheckboxes) {
                const chapterTitle = checkbox.dataset.title;
                const chapterData = novelChapters.find(c => c.title === chapterTitle);
                
                // åªæ·»åŠ å·²æ‹¼æ¥çš„ç« èŠ‚
                if (chapterData && chapterData.spliced) {
                    const novel = state.novelName;
                    const chapter = sanitizeTitleForFilename(chapterTitle);
                    const format = state.globalConfig.audio_export?.format || 'mp3';
					filePathsToDownload.push(`${novel}/${chapter}.${format}`);
                }
            }
        }

        if (filePathsToDownload.length === 0) {
            alert('æ²¡æœ‰æ‰¾åˆ°å¯ä»¥ä¸‹è½½çš„å·²æ‹¼æ¥æ–‡ä»¶ã€‚');
            return;
        }

        setStatus(`æ­£åœ¨æ‰“åŒ… ${filePathsToDownload.length} ä¸ªæ–‡ä»¶...`, 'info');
        dom.downloadSpliceBtn.disabled = true;
        dom.downloadSpliceBtn.textContent = 'æ‰“åŒ…ä¸­...';

        try {
            const response = await fetch('/api/download_spliced_chapters', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_paths: filePathsToDownload })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.detail || 'æ‰“åŒ…å¤±è´¥ã€‚');
            }

            // å°†å“åº”ä½“è½¬æ¢ä¸º Blob
            const blob = await response.blob();
            
            // ä»å“åº”å¤´ä¸­è·å–æ¨èçš„æ–‡ä»¶å
            const contentDisposition = response.headers.get('content-disposition');
            let filename = 'chapters.zip'; // é»˜è®¤æ–‡ä»¶å
            if (contentDisposition) {
                const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                if (filenameMatch.length > 1) {
                    filename = filenameMatch[1];
                }
            }

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ a æ ‡ç­¾æ¥è§¦å‘ä¸‹è½½
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // é‡Šæ”¾ Object URL
            URL.revokeObjectURL(link.href);
            setStatus('æ–‡ä»¶æ‰“åŒ…ä¸‹è½½æˆåŠŸï¼', 'success');

        } catch (error) {
            setStatus(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
        } finally {
            dom.downloadSpliceBtn.disabled = false;
            dom.downloadSpliceBtn.textContent = 'ä¸‹è½½å£°éŸ³';
        }
    });

	
	dom.chapterPlayStopBtn.addEventListener('click', toggleChapterAudio);

    dom.characterListEl.addEventListener('click', e => {
        const li = e.target.closest('li.selectable');
        if (!li) return; // å¦‚æœæ²¡ç‚¹åˆ°è¡Œï¼Œå°±ä»€ä¹ˆéƒ½ä¸åš

        // --- 1. è§’è‰²é€‰æ‹©é€»è¾‘ (ä¿æŒä¸å˜) ---
        state.selectedCharacter = li.dataset.characterName;
        // ç§»é™¤æ‰€æœ‰æ—§çš„é€‰ä¸­æ ·å¼
        document.querySelectorAll('#character-list li.selected').forEach(el => el.classList.remove('selected'));
        // ä¸ºå½“å‰è¡Œæ·»åŠ é€‰ä¸­æ ·å¼
        li.classList.add('selected');
        setStatus(`å·²é€‰ä¸­è§’è‰²: ${state.selectedCharacter}`, 'info');

        // --- 2. è¯•å¬å’Œç®€ä»‹æŒ‰é’®é€»è¾‘ (ä¿æŒä¸å˜) ---
		if (e.target.matches('.audio-player-btn')) {
			const timbreName = state.characterMapping[e.target.closest('li').dataset.characterName];
			if(timbreName) toggleSimpleAudio(e.target, `/wav/${timbreName}/1.wav`);
		}
		
        if (e.target.matches('.btn-profile')) {
            showProfileModal(e.target.dataset.characterName);
        }

        // *** æ ¸å¿ƒä¿®æ”¹ 2: å®ç°é«˜äº®å’Œæ»šåŠ¨é€»è¾‘ ***

        // a. æ£€æŸ¥ç¼–è¾‘å™¨æ˜¯å¦å¯è§
        if (dom.editorView.style.display !== 'block' || state.novelData.length === 0) {
            return; // å¦‚æœç¼–è¾‘å™¨ä¸å¯è§æˆ–æ²¡æœ‰å†…å®¹ï¼Œåˆ™ä¸æ‰§è¡Œåç»­æ“ä½œ
        }

        const characterToHighlight = state.selectedCharacter;
        const tableRows = dom.contentTableBody.querySelectorAll('tr');
        let firstHighlightedRow = null;

        // b. éå†æ‰€æœ‰è¡Œï¼Œè¿›è¡Œé«˜äº®å¤„ç†
        tableRows.forEach((row, index) => {
            // ä» state.novelData è·å–è¯¥è¡Œå¯¹åº”çš„ speakerï¼Œè¿™æ¯”ä»DOMè¯»å–æ›´å¯é 
            const speaker = state.novelData[index] ? state.novelData[index].speaker : '';
            
            if (speaker === characterToHighlight) {
                row.classList.add('highlighted-row');
                // è®°å½•ç¬¬ä¸€ä¸ªè¢«é«˜äº®çš„è¡Œ
                if (!firstHighlightedRow) {
                    firstHighlightedRow = row;
                }
            } else {
                // ç§»é™¤å…¶ä»–è¡Œå¯èƒ½å­˜åœ¨çš„é«˜äº®
                row.classList.remove('highlighted-row');
            }
        });

        // c. å¦‚æœæ‰¾åˆ°äº†åŒ¹é…çš„è¡Œï¼Œåˆ™æ»šåŠ¨åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…è¡Œ
        if (firstHighlightedRow) {
            firstHighlightedRow.scrollIntoView({
                behavior: 'smooth', // å¹³æ»‘æ»šåŠ¨
                block: 'center'     // å°†å…¶æ»šåŠ¨åˆ°è§†å£çš„ä¸­å¤®
            });
            setStatus(`å·²é«˜äº®è§’è‰²ã€Œ${characterToHighlight}ã€çš„æ‰€æœ‰å¯¹è¯ã€‚`, 'info');
        } else {
             setStatus(`å½“å‰ç« èŠ‚å†…å®¹ä¸­æœªæ‰¾åˆ°è§’è‰²ã€Œ${characterToHighlight}ã€çš„å¯¹è¯ã€‚`, 'info');
        }
    });
    dom.characterListEl.addEventListener('dblclick', e => {
        const li = e.target.closest('li.character-row');
        if (li) {
            const characterName = li.dataset.characterName;
            showCharacterDialogues(characterName);
        }
    });
	
	
	// 6. æ¨¡æ€æ’­æ”¾å™¨å†…éƒ¨çš„äº‹ä»¶ç›‘å¬å™¨ 
	dom.playerPlayPauseBtn.addEventListener('click', () => {
		if (state.globalAudioPlayer) {
			if (state.globalAudioPlayer.paused) {
				state.globalAudioPlayer.play();
			} else {
				state.globalAudioPlayer.pause();
			}
		}
	});

	dom.playerProgressBar.addEventListener('input', () => {
		if (state.globalAudioPlayer) {
			state.globalAudioPlayer.currentTime = dom.playerProgressBar.value;
		}
	});

	dom.playerModalCloseBtn.addEventListener('click', stopAllAudio);
	dom.audioPlayerModal.addEventListener('click', (e) => {
		if (e.target === dom.audioPlayerModal) {
			stopAllAudio();
		}
	});

    // *** æ ¸å¿ƒä¿®æ”¹ 4: ä¸ºæ–°æ¨¡æ€æ¡†æ·»åŠ å…³é—­äº‹ä»¶ ***
    dom.dialogueModalCloseBtn.addEventListener('click', () => {
        dom.dialogueModal.style.display = 'none';
    });
    dom.dialogueModal.addEventListener('click', (e) => {
        if (e.target === dom.dialogueModal) {
            dom.dialogueModal.style.display = 'none';
        }
    });

    dom.timbreFile.addEventListener('change', e => { if (e.target.files[0]) showTimbreUploadModal(e.target.files[0]); e.target.value = ''; });
    dom.confirmUploadBtn.addEventListener('click', handleTimbreUpload);
    dom.cancelUploadBtn.addEventListener('click', hideTimbreUploadModal);
    
    dom.contentTableBody.addEventListener('click', async (event) => { // å°†å‡½æ•°æ ‡è®°ä¸º async
        const row = event.target.closest('tr');
        if (!row) return;

        // è·å–å½“å‰è¡Œçš„ç´¢å¼•å’Œç”ŸæˆæŒ‰é’®
        const index = Array.from(dom.contentTableBody.children).indexOf(row);
        const generateBtn = row.querySelector('.btn-generate');

        // --- â€œç”Ÿæˆâ€æŒ‰é’®çš„é€»è¾‘ ---
        if (event.target === generateBtn) {
            // *** æ ¸å¿ƒä¿®æ”¹ 1: ç«‹å³ç¦ç”¨æŒ‰é’®å¹¶æ›´æ–°UI ***
            generateBtn.disabled = true;
            generateBtn.textContent = 'ç”Ÿæˆä¸­...';
            setStatus(`æ­£åœ¨ä¸ºç¬¬ ${index + 1} è¡Œç”ŸæˆéŸ³é¢‘...`, 'info');

            const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
            const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
            const speaker = state.novelData[index].speaker;
			const timbreSelect = row.querySelector('.timbre-override-select');
			const timbre = timbreSelect ? timbreSelect.value : state.characterMapping[speaker];
            
            if (!timbre) { 
                setStatus(`é”™è¯¯: è§’è‰²'${speaker}'æœªåˆ†é…éŸ³è‰²`, 'error');
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                generateBtn.disabled = false;
                generateBtn.textContent = 'ç”ŸæˆéŸ³é¢‘';
                return; 
            }
            
            const payload = {
                novel_name: state.novelName, chapter_name: currentChapterName, row_index: index, 
                speaker: speaker, timbre: timbre, tts_text: state.novelData[index].content,
                inference_mode: row.querySelector('.mode-select').value, 
                instruct_text: row.querySelector('.instruct-input').value.trim(),
				tts_model: row.querySelector('.tts-model-select').value
            };

            try {
                const details = await loadTimbreDetails(timbre);
                payload.prompt_audio = details.promptAudio;
                payload.prompt_text = details.promptText;

                const fileName = await generateSpeech(payload); // generateSpeech ç°åœ¨å†…éƒ¨å¤„ç†é‡è¯•
                
                if (fileName) {
                    state.generatedFiles[index] = fileName;
                    const playBtn = row.querySelector('.btn-play');
                    if (playBtn) {
                        playBtn.disabled = false;
                        playBtn.classList.add('playable');
					}
                    const effectsBtn = row.querySelector('.btn-effects');
                    if (effectsBtn) effectsBtn.disabled = false;
                    setStatus(`ç¬¬ ${index + 1} è¡ŒéŸ³é¢‘ç”ŸæˆæˆåŠŸï¼`, 'success');
                } else {
                    // generateSpeech è¿”å› null è¡¨ç¤ºæœ€ç»ˆå¤±è´¥
                    setStatus(`ç¬¬ ${index + 1} è¡ŒéŸ³é¢‘ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æ—¥å¿—ã€‚`, 'error');
                }
            } catch (err) {
                // è¿™ä¸ª catch ä¸»è¦æ•è· loadTimbreDetails çš„é”™è¯¯
                setStatus(`ç”Ÿæˆå¤±è´¥: ${err.message}`, 'error');
            } finally {
                // *** æ ¸å¿ƒä¿®æ”¹ 2: æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½æ¢å¤æŒ‰é’®çŠ¶æ€ ***
                generateBtn.disabled = false;
                generateBtn.textContent = 'ç”ŸæˆéŸ³é¢‘';
            }
        }

        // --- â€œæ’­æ”¾â€æŒ‰é’®çš„é€»è¾‘ ---
        if (event.target.matches('.btn-play')) { 
            const row = event.target.closest('tr');
            const index = Array.from(dom.contentTableBody.children).indexOf(row);

            if (state.generatedFiles[index] && state.selectedChapterPaths.length === 1) {
                
                // 1. ä» state ä¸­è·å–å½“å‰ç« èŠ‚çš„åŸå§‹è·¯å¾„ï¼Œä¾‹å¦‚ "å°è¯´å/ç« èŠ‚å.json"
                const fullChapterPath = state.selectedChapterPaths[0];
                
                // 2. è§£æå‡ºåŸå§‹çš„ç« èŠ‚æ ‡é¢˜
                //    - å»æ‰ ".json" åç¼€
                //    - åˆ†å‰²è·¯å¾„å¹¶å–æœ€åä¸€éƒ¨åˆ†
                const pathParts = fullChapterPath.replace(/\.json$/, '').split(/[/\\]/);
                const originalChapterTitle = pathParts[pathParts.length - 1];

                // 3. ä½¿ç”¨ sanitizeTitleForFilename å‡½æ•°å¯¹åŸå§‹æ ‡é¢˜è¿›è¡Œå®‰å…¨å¤„ç†ï¼Œ
                //    ä½¿å…¶ä¸åç«¯ç”Ÿæˆæ–‡ä»¶å¤¹æ—¶ä½¿ç”¨çš„åç§°å®Œå…¨ä¸€è‡´ã€‚
                const safeChapterName = sanitizeTitleForFilename(originalChapterTitle);

                // 4. æ‹¼æ¥æˆæœ€ç»ˆçš„ã€æ­£ç¡®çš„URL
                const audioPath = `/output/${state.novelName}/wavs/${safeChapterName}/${state.generatedFiles[index]}`;

                // 5. è°ƒç”¨æ’­æ”¾å‡½æ•°
                toggleSimpleAudio(event.target, audioPath);
            }
        }
				
        // --- â€œç‰¹æ•ˆâ€æŒ‰é’®çš„é€»è¾‘ ---
		if (event.target.matches('.effects-menu button')) {
			const effectBtn = event.target;
            const mainEffectsBtn = effectBtn.closest('.popover-container').querySelector('.btn-effects');

            // å¦‚æœç‚¹å‡»çš„æ˜¯â€œå¤šäººåŒå£°â€ï¼Œåˆ™æ˜¾ç¤ºæ–°æ¨¡æ€æ¡†
            if (effectBtn.dataset.effect === 'choral') {
                const index = Array.from(dom.contentTableBody.children).indexOf(row);
                const fileName = state.generatedFiles[index];
                if (!fileName) {
                    setStatus('é”™è¯¯ï¼šå¿…é¡»å…ˆç”ŸæˆåŸºç¡€éŸ³é¢‘æ‰èƒ½åº”ç”¨ç‰¹æ•ˆã€‚', 'error');
                    return;
                }
                
                // æ‰“å¼€â€œå¤šäººåŒå£°â€æ¨¡æ€æ¡†
                openChoralModal(index);
                mainEffectsBtn.blur(); // å…³é—­ç‰¹æ•ˆèœå•
                return; // ç»“æŸæœ¬æ¬¡ç‚¹å‡»å¤„ç†
            }
			
			const effectType = effectBtn.dataset.effect;
			const index = Array.from(dom.contentTableBody.children).indexOf(row);
			const fileName = state.generatedFiles[index];
			if (!fileName) {
				setStatus('é”™è¯¯ï¼šå¿…é¡»å…ˆç”ŸæˆéŸ³é¢‘æ‰èƒ½åº”ç”¨ç‰¹æ•ˆã€‚', 'error');
				return;
			}

			const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
			const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
			
			const payload = {
				novel_name: state.novelName,
				chapter_name: currentChapterName,
				file_name: fileName,
				effect_type: effectType
			};

            // *** æ ¸å¿ƒä¿®æ”¹ï¼šæ·»åŠ UIåé¦ˆå’Œå¼‚æ­¥å¤„ç† ***
            const playBtnForEffect = row.querySelector('.btn-play');
            const originalEffectBtnText = effectBtn.innerHTML;
            effectBtn.innerHTML = `<span>â³</span> å¤„ç†ä¸­...`;
            effectBtn.disabled = true;
            mainEffectsBtn.disabled = true; // ç¦ç”¨ä¸»ç‰¹æ•ˆæŒ‰é’®é˜²æ­¢å†æ¬¡æ‰“å¼€èœå•
			setStatus(`æ­£åœ¨åº”ç”¨ "${effectBtn.textContent.trim()}" ç‰¹æ•ˆ...`, 'info');
            
            // ä½¿ç”¨ async/await æ–¹å¼å¤„ç†è¯·æ±‚
			(async () => {
                try {
                    const result = await fetchFromServer('/api/apply_effect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    setStatus(result.message, 'success');
                    // ç‰¹æ•ˆåº”ç”¨æˆåŠŸåï¼Œè‡ªåŠ¨æ’­æ”¾ç»“æœ
                    const audioPath = `/output/${state.novelName}/wavs/${currentChapterName}/${fileName}`;
                    if (playBtnForEffect) {
                        toggleSimpleAudio(playBtnForEffect, audioPath);
                    }
                } catch (err) {
                    setStatus(`ç‰¹æ•ˆåº”ç”¨å¤±è´¥: ${err.message}`, 'error');
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    effectBtn.innerHTML = originalEffectBtnText;
                    effectBtn.disabled = false;
                    mainEffectsBtn.disabled = false;
                    // å…³é—­èœå• (é€šè¿‡è®©ä¸»æŒ‰é’®å¤±å»ç„¦ç‚¹)
                    mainEffectsBtn.blur();
                }
            })();
		}
		
        if (event.target.matches('.btn-delete-row')) {
            const index = parseInt(event.target.dataset.index, 10);
            if (confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤ç¬¬ ${index + 1} è¡Œå—ï¼Ÿ`)) {
                state.novelData.splice(index, 1);
                renderContentTable();
                markChapterAsDirty();
            }
        }
        // --- â€œæ’å…¥è¡Œâ€æŒ‰é’®çš„é€»è¾‘ ---
        if (event.target.matches('.btn-insert-row')) {
            const index = parseInt(event.target.dataset.index, 10);
            const newRow = { speaker: "æ—ç™½", content: "ï¼ˆæ–°æ’å…¥çš„è¡Œï¼‰", tone: "neutral", intensity: 5, delay: 500 };
            state.novelData.splice(index + 1, 0, newRow);
            renderContentTable();
            markChapterAsDirty();
        }
    });


	// New listener for adding a row at the end
	dom.addRowStartBtn.addEventListener('click', () => {
		const newRow = { speaker: "æ—ç™½", content: "ï¼ˆæ–°æ’å…¥çš„è¡Œï¼‰", tone: "neutral", intensity: 5, delay: 500 };
		state.novelData.unshift(newRow);
		renderContentTable();
		markChapterAsDirty();
	});

	// Modify the existing blur listener to also enable the save button
	dom.contentTableBody.addEventListener('blur', (event) => {
		if (event.target.matches('.content-cell')) {
			const row = event.target.closest('tr');
			const index = Array.from(dom.contentTableBody.children).indexOf(row);
			const newContent = event.target.textContent.trim();
			if (state.novelData[index] && state.novelData[index].content !== newContent) {
				state.novelData[index].content = newContent;
				setStatus(`ç¬¬${index+1}è¡Œ: å†…å®¹å·²æ›´æ–°`, 'info');
				markChapterAsDirty(); // Enable save button on content change
			}
		}
	}, true);

	// New listener for the save button
	dom.saveChapterBtn.addEventListener('click', async () => {
		if (state.selectedChapterPaths.length !== 1) return;
		const filepath = state.selectedChapterPaths[0];
		setStatus('æ­£åœ¨ä¿å­˜ç« èŠ‚ä¿®æ”¹...', 'info');
		try {
			const payload = { filepath: filepath, content: state.novelData };
			const result = await fetchFromServer('/api/update_chapter_content', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});
			setStatus(result.message, 'success');
			dom.saveChapterBtn.disabled = true; // Disable after successful save
		} catch (error) {
			setStatus(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
		}
	});
    dom.profileModalCloseBtn.addEventListener('click', () => dom.profileModal.style.display = 'none');
    dom.profileModal.addEventListener('click', (e) => { if (e.target === dom.profileModal) dom.profileModal.style.display = 'none'; });
	
    dom.manageReplaceDictBtn.addEventListener('click', async () => {
        if (!state.novelName) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå°è¯´é¡¹ç›®ã€‚');
            return;
        }
        dom.replaceDictNovelName.textContent = state.novelName;
        dom.replaceDictModal.style.display = 'flex';
        await loadReplaceDict();
    });

    dom.closeReplaceDictBtn.addEventListener('click', () => {
        dom.replaceDictModal.style.display = 'none';
    });
    // ç‚¹å‡»èƒŒæ™¯å…³é—­
    dom.replaceDictModal.addEventListener('click', (e) => {
        if (e.target === dom.replaceDictModal) {
            dom.replaceDictModal.style.display = 'none';
        }
    });

    dom.addReplaceRuleBtn.addEventListener('click', async () => {
        const original = dom.newOriginalWord.value.trim();
        const replacement = dom.newReplacementWord.value.trim();
        const description = dom.newDescription.value.trim();

        if (!original || !replacement) {
            alert('åŸè¯å’Œæ›¿æ¢è¯ä¸èƒ½ä¸ºç©ºã€‚');
            return;
        }

        state.replaceDict.push({ original_word: original, replacement_word: replacement, description: description });
        await saveReplaceDict();
        dom.newOriginalWord.value = '';
        dom.newReplacementWord.value = '';
        dom.newDescription.value = '';
        renderReplaceRules();
    });

    dom.replaceRuleSearchInput.addEventListener('input', () => {
        renderReplaceRules(dom.replaceRuleSearchInput.value);
    });

    dom.replaceRulesList.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.matches('.btn-delete-rule')) {
            const li = target.closest('li');
            const originalWordToDelete = li.dataset.originalWord;
            const replacementWordToDelete = li.dataset.replacementWord;

            if (confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤è§„åˆ™ã€Œ${originalWordToDelete} â†’ ${replacementWordToDelete}ã€å—ï¼Ÿ`)) {
                //  æŸ¥æ‰¾è¦åˆ é™¤è§„åˆ™çš„çœŸå®ç´¢å¼•
                const indexToDelete = state.replaceDict.findIndex(rule => 
                    rule.original_word === originalWordToDelete && 
                    rule.replacement_word === replacementWordToDelete
                );

                if (indexToDelete !== -1) {
                    state.replaceDict.splice(indexToDelete, 1); 
                    await saveReplaceDict();
                    renderReplaceRules(dom.replaceRuleSearchInput.value); // åˆ·æ–°æ—¶ä¿ç•™æœç´¢çŠ¶æ€
                    setStatus(`å·²åˆ é™¤è§„åˆ™: ${originalWordToDelete} â†’ ${replacementWordToDelete}`, 'success');
                } else {
                    setStatus('é”™è¯¯ï¼šæœªæ‰¾åˆ°è¦åˆ é™¤çš„è§„åˆ™ã€‚', 'error');
                }
            }
        }
    });
	
	dom.filterBtn.addEventListener('click', () => {
		dom.filterModal.style.display = 'flex';
		// Populate modal with current filter state
		document.querySelector(`input[name="filterStatus"][value="${state.filter.status}"]`).checked = true;
		dom.rangeStartInput.value = state.filter.start || '';
		dom.rangeEndInput.value = state.filter.end || '';
	});

	function closeFilterModal() {
		dom.filterModal.style.display = 'none';
	}

	dom.applyFilterBtn.addEventListener('click', () => {
		state.filter.status = document.querySelector('input[name="filterStatus"]:checked').value;
		state.filter.start = dom.rangeStartInput.value;
		state.filter.end = dom.rangeEndInput.value;
		renderChapterList(); // Re-render the list with new filters
		closeFilterModal();
	});

	dom.clearFilterBtn.addEventListener('click', () => {
		state.filter.status = 'all';
		state.filter.start = null;
		state.filter.end = null;
		renderChapterList(); // Re-render the full list
		closeFilterModal();
	});

	// Also add closing handlers for the modal overlay
	dom.filterModal.addEventListener('click', (e) => {
		if (e.target === dom.filterModal) {
			closeFilterModal();
		}
	});
	
	dom.transcribeBtn.addEventListener('click', async () => {
		if (!state.fileToUpload) {
			alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶ã€‚");
			return;
		}

		// --- UI åé¦ˆ ---
		const originalBtnText = dom.transcribeBtn.innerHTML;
		dom.transcribeBtn.innerHTML = 'è¯†åˆ«ä¸­...';
		dom.transcribeBtn.disabled = true;
		setStatus('æ­£åœ¨è‡ªåŠ¨è¯†åˆ«æ–‡æœ¬...', 'info');

		const formData = new FormData();
		formData.append('file', state.fileToUpload);

		try {
			const result = await fetchFromServer('/api/stt_elevenlabs', {
				method: 'POST',
				body: formData
			});

			if (result.status === 'success') {
				dom.newTimbreTextInput.value = result.text;
				setStatus('æ–‡æœ¬è¯†åˆ«æˆåŠŸï¼', 'success');
			} else {
				// å¦‚æœåç«¯è¿”å›äº†å·²çŸ¥çš„é”™è¯¯ä¿¡æ¯
				throw new Error(result.message || 'è¯†åˆ«å¤±è´¥ï¼ŒæœªçŸ¥é”™è¯¯');
			}

		} catch (error) {
			setStatus(`æ–‡æœ¬è¯†åˆ«å¤±è´¥: ${error.message}`, 'error');
			alert(`æ–‡æœ¬è¯†åˆ«å¤±è´¥: ${error.message}`);
		} finally {
			// --- æ¢å¤ UI ---
			dom.transcribeBtn.innerHTML = originalBtnText;
			dom.transcribeBtn.disabled = false;
		}
	});
	
    dom.previewUploadBtn.addEventListener('click', () => {
        if (state.fileToUpload) {
            // è°ƒç”¨æ–°çš„ã€ä¸“é—¨çš„å‡½æ•°
            toggleLocalBlobAudio(dom.previewUploadBtn, state.fileToUpload);
        }
    });
	
    async function loadReplaceDict() {
        if (!state.novelName) {
            dom.replaceRulesList.innerHTML = '<p class="placeholder-text">è¯·å…ˆé€‰æ‹©å°è¯´é¡¹ç›®</p>';
            return;
        }
        setStatus(`æ­£åœ¨åŠ è½½å°è¯´ã€Œ${state.novelName}ã€çš„æ›¿æ¢è¯å…¸...`, 'info');
        try {
            // Note: We use _t parameter to prevent caching for dynamic content
            const data = await fetchFromServer(`/api/novel/${encodeURIComponent(state.novelName)}/replace_dict?_t=${new Date().getTime()}`);
            state.replaceDict = data.rules || [];
            renderReplaceRules();
            setStatus(`å°è¯´ã€Œ${state.novelName}ã€æ›¿æ¢è¯å…¸åŠ è½½æˆåŠŸã€‚`, 'success');
        } catch (error) {
            setStatus(`åŠ è½½æ›¿æ¢è¯å…¸å¤±è´¥: ${error.message}`, 'error');
            state.replaceDict = [];
            renderReplaceRules();
        }
    }

    async function saveReplaceDict() {
        if (!state.novelName) {
            setStatus('è¯·å…ˆé€‰æ‹©å°è¯´é¡¹ç›®å†ä¿å­˜æ›¿æ¢è¯å…¸ã€‚', 'error');
            return;
        }
        setStatus(`æ­£åœ¨ä¿å­˜å°è¯´ã€Œ${state.novelName}ã€çš„æ›¿æ¢è¯å…¸...`, 'info');
        try {
            await fetchFromServer(`/api/novel/${encodeURIComponent(state.novelName)}/replace_dict`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rules: state.replaceDict })
            });
            setStatus(`å°è¯´ã€Œ${state.novelName}ã€æ›¿æ¢è¯å…¸ä¿å­˜æˆåŠŸã€‚`, 'success');
        } catch (error) {
            setStatus(`ä¿å­˜æ›¿æ¢è¯å…¸å¤±è´¥: ${error.message}`, 'error');
        }
    }

    function renderReplaceRules(filterTerm = '') {
        const listEl = dom.replaceRulesList;
        listEl.innerHTML = '';
        
        const lowerFilterTerm = filterTerm.toLowerCase().trim();
        const filteredRules = state.replaceDict.filter(rule => 
            rule.original_word.toLowerCase().includes(lowerFilterTerm) ||
            rule.replacement_word.toLowerCase().includes(lowerFilterTerm) ||
            (rule.description && rule.description.toLowerCase().includes(lowerFilterTerm))
        );

        if (filteredRules.length === 0) {
            listEl.innerHTML = '<p class="placeholder-text">æš‚æ— æ›¿æ¢è§„åˆ™æˆ–æ²¡æœ‰åŒ¹é…é¡¹ã€‚</p>';
            return;
        }

        filteredRules.forEach((rule, index) => { // è¿™é‡Œçš„ index åªæ˜¯ä¸ºäº†æ¸²æŸ“ï¼Œä¸å†å­˜å‚¨åˆ° dataset
            const li = document.createElement('li');
            // ä¸ºäº†è°ƒè¯•æ–¹ä¾¿ï¼Œå¯ä»¥æš‚æ—¶å­˜å‚¨è§„åˆ™çš„åŸå§‹è¯å’Œæ›¿æ¢è¯
            li.dataset.originalWord = rule.original_word;
            li.dataset.replacementWord = rule.replacement_word;
            li.innerHTML = `
                <div class="replace-rule-display" style="display: flex; align-items: center; justify-content: space-between; flex-grow: 1;">
                    <div>
                        <span class="original-word" style="font-weight: bold;">${rule.original_word}</span> 
                        <span style="color: var(--text-color-secondary); margin: 0 0.5rem;">â†’</span> 
                        <span class="replacement-word" style="color: var(--primary-color);">${rule.replacement_word}</span>
                        ${rule.description ? `<span class="description" style="margin-left: 1rem; font-size: 0.85em; color: var(--text-color-secondary);">(${rule.description})</span>` : ''}
                    </div>
                    <div class="rule-actions" style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-danger btn-delete-rule">åˆ é™¤</button>
                    </div>
                </div>
            `;
            listEl.appendChild(li);
        });
    }

    // === 6. INITIALIZATION ===    
	async function initialize() {
        setStatus('æ­£åœ¨åˆå§‹åŒ–åº”ç”¨...');
        try {
            state.globalConfig = await fetchFromServer(`/api/get_llm_config?_t=${new Date().getTime()}`);
            
            // --- é…ç½®åŠ è½½æˆåŠŸåçš„é€»è¾‘ ---
            const mainModelSelect = dom.llmModelSelector;
            mainModelSelect.innerHTML = '';
            if (state.globalConfig.models) {
                for (const modelId in state.globalConfig.models) {
                    const model = state.globalConfig.models[modelId];
                    const option = document.createElement('option');
                    option.value = modelId;
                    option.textContent = model.display_name || modelId;
                    mainModelSelect.appendChild(option);
                }
            }

            state.selectedLLM = state.globalConfig.general?.default_model || 'gemini-2.5-flash';
            mainModelSelect.value = state.selectedLLM;
			
			
			const elevenlabsConfig = state.globalConfig.elevenlabs; // elevenlabsé…ç½®
			const hasElevenlabsKey = elevenlabsConfig && elevenlabsConfig.api_key && elevenlabsConfig.api_key.trim() !== '';
            
            if (hasElevenlabsKey) {
                dom.transcribeBtn.style.display = 'inline-flex'; // å¦‚æœæœ‰ Keyï¼Œåˆ™æ˜¾ç¤ºæŒ‰é’®
                dom.transcribeBtn.title = ''; // æ¸…é™¤æç¤ºï¼Œç¦ç”¨çŠ¶æ€ç”±æ–‡ä»¶é€‰æ‹©å†³å®š
            } else {
                dom.transcribeBtn.style.display = 'none'; // æ²¡æœ‰ Keyï¼Œåˆ™éšè—æŒ‰é’®
                setStatus('ElevenLabs API Key æœªé…ç½®ï¼Œè‡ªåŠ¨è¯†åˆ«æ–‡æœ¬åŠŸèƒ½å·²éšè—ã€‚', 'warning');
            }
            
        } catch (error) {
            setStatus('åŠ è½½å…¨å±€é…ç½®å¤±è´¥ï¼Œå°†ä½¿ç”¨é»˜è®¤è®¾ç½®ã€‚', 'warning');
            // --- æä¾›ä¸€ä¸ªé»˜è®¤çš„ globalConfig ç»“æ„ï¼Œç¡®ä¿åç»­ä»£ç ä¸ä¼šå›  undefined å‡ºé”™ ---
            state.globalConfig = {
                general: { default_model: 'gemini-2.5-flash' },
                models: {
                    'gemini-2.5-flash': { display_name: 'Gemini Flash' },
                    'qwen-plus-latest': { display_name: 'é€šä¹‰åƒé—® Plus' }
                },
                audio_export: { format: 'mp3', quality: '192k' }
            };
            // åŒæ ·éœ€è¦å¡«å……ä¸»ç•Œé¢çš„ä¸‹æ‹‰æ¡†
            const mainModelSelect = dom.llmModelSelector;
            mainModelSelect.innerHTML = '';
             for (const modelId in state.globalConfig.models) {
                const model = state.globalConfig.models[modelId];
                const option = document.createElement('option');
                option.value = modelId;
                option.textContent = model.display_name || modelId;
                mainModelSelect.appendChild(option);
            }
            mainModelSelect.value = state.globalConfig.general.default_model;
			
            dom.transcribeBtn.style.display = 'none';
        }

        // --- å°†è¿™ä¸¤ä¸ªè°ƒç”¨ç§»åˆ° try...catch ä¹‹åï¼Œç¡®ä¿å®ƒä»¬æ€»èƒ½è¢«æ‰§è¡Œ ---
		await loadNovels();
		await loadTimbres(); // 1. å…ˆåŠ è½½æ‰€æœ‰æ•°æ®å¹¶å¡«å……UIæ§ä»¶
		
		renderTimbreList();
		updateRelatedRolesPopovers();
        setStatus('åˆå§‹åŒ–å®Œæˆã€‚', 'info');
    }
    
    initialize();
});
</script>

<!-- NEW: Audio Player Modal -->
<div id="audioPlayerModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <h3 id="playerModalTitle" class="modal-header">æ­£åœ¨æ’­æ”¾...</h3>
        <div class="player-modal-body">
            <div class="player-controls">
                <button id="playerPlayPauseBtn" class="btn btn-primary">â¸ï¸</button>
            </div>
            <div class="player-timeline">
                <span id="playerCurrentTime" class="time-display">00:00</span>
                <input type="range" id="playerProgressBar" class="progress-bar-slider" value="0" step="0.1">
                <span id="playerTotalDuration" class="time-display">00:00</span>
            </div>
        </div>
        <div class="modal-actions">
            <button id="playerModalCloseBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<!-- NEW: Timbres Management Modal -->
<div id="timbresManageModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 900px; height: 85vh; display: flex; flex-direction: column;">
        <h3 class="modal-header">éŸ³è‰²åº“ç®¡ç†å™¨</h3>
        <div class="manager-container" style="display: flex; flex-grow: 1; gap: 1rem; overflow: hidden;">
            <!-- Left Panel: Categories -->
            <div class="manager-panel" style="flex: 0.8; border: 1px solid var(--border-color); border-radius: 4px; display: flex; flex-direction: column;">
                <div id="manager-category-list" class="scrollable-content" style="padding: 0.5rem;"></div>
                <div class="input-group" style="padding: 0.5rem; border-top: 1px solid var(--border-color); margin-bottom: 0; display:flex; gap: 0.5rem;">
                    <input type="text" id="managerNewCategoryInput" placeholder="è¾“å…¥æ–°åˆ†ç±»å">
                    <button id="managerAddCategoryBtn" class="btn btn-primary" style="flex-shrink: 0;">åˆ›å»º</button>
                </div>
            </div>
            <!-- Right Panel: Timbres in selected category -->
            <div class="manager-panel" style="flex: 2; border: 1px solid var(--border-color); border-radius: 4px; display: flex; flex-direction: column;">
                <h4 id="manager-timbres-title" style="padding: 0.8rem; margin: 0; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">é€‰æ‹©ä¸€ä¸ªåˆ†ç±»</h4>
                <div id="manager-timbres-list" class="scrollable-content info-list"></div>
            </div>
        </div>
        <div class="modal-actions">
            <button id="closeTimbresManageBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>
</body>
</html>